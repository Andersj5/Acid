{"version":3,"file":"index.js","sources":["../source/namespace/index.js","../source/internal/object.js","../source/array/asyncEach.js","../source/array/each.js","../source/internal/is.js","../source/array/ensure.js","../source/array/flatten.js","../source/array/remove.js","../source/array/chunk.js","../source/array/flow.js","../source/array/rest.js","../source/array/clear.js","../source/array/sortToObject.js","../source/array/groupby.js","../source/array/right.js","../source/array/clone.js","../source/number/math.js","../source/array/sample.js","../source/array/compact.js","../source/array/indexby.js","../source/internal/array.js","../source/array/shuffle.js","../source/array/countby.js","../source/array/initial.js","../source/array/smallest.js","../source/array/createrange.js","../source/array/intersect.js","../source/array/sortAlphabet.js","../source/array/difference.js","../source/array/invoke.js","../source/array/drop.js","../source/array/isMatch.js","../source/array/sortedIndex.js","../source/array/largest.js","../source/array/sumof.js","../source/array/eachAsync.js","../source/array/last.js","../source/array/take.js","../source/array/mapAsync.js","../source/array/unique.js","../source/array/union.js","../source/array/compactMapAsync.js","../source/array/numSort.js","../source/array/findDifference.js","../source/array/object.js","../source/array/without.js","../source/array/findIndex.js","../source/array/partition.js","../source/array/xor.js","../source/array/findSum.js","../source/array/pluck.js","../source/array/zip.js","../source/array/first.js","../source/array/rNumSort.js","../source/browser/agent.js","../source/browser/event.js","../source/browser/isEnter.js","../source/browser/appState.js","../source/browser/frag.js","../source/browser/append.js","../source/object/each.js","../source/browser/attribute.js","../source/utility/promise.js","../source/string/range.js","../source/browser/selector.js","../source/browser/import.js","../source/browser/ready.js","../source/browser/saveDimentions.js","../source/function/ifInvoke.js","../source/browser/batch.js","../source/browser/info.js","../source/utility/json.js","../source/browser/console.js","../source/browser/is.js","../source/collection/sortNewest.js","../source/collection/sortOldest.js","../source/function/ary.js","../source/function/curry.js","../source/function/ntimes.js","../source/function/stub.js","../source/utility/each.js","../source/function/bind.js","../source/function/negate.js","../source/function/overEvery.js","../source/function/timing.js","../source/function/chain.js","../source/function/in.js","../source/function/nthArg.js","../source/function/rearged.js","../source/function/wrap.js","../source/number/is.js","../source/object/hasKeys.js","../source/object/pick.js","../source/object/compactKeys.js","../source/object/isMatch.js","../source/object/zip.js","../source/object/invert.js","../source/object/omit.js","../source/string/case.js","../source/string/replace.js","../source/string/sanitize.js","../source/string/tokenize.js","../source/string/truncate.js","../source/string/typography.js","../source/utility/assignDeep.js","../source/utility/cacheNativeMethod.js","../source/utility/ifNotEqual.js","../source/utility/isEqual.js","../source/utility/propertyMatch.js","../source/utility/toPath.js","../source/utility/uid.js","../source/utility/get.js","../source/utility/model.js","../source/utility/toggle.js"],"sourcesContent":["let cacheSuper;\n/**\n * Acid Object accessible through $ default method is model.\n *\n * @function $\n * @returns {*} The return value of the superMethod. The default superMethod is model.\n *\n * @example\n * $('modelName', {example: 1});\n * // -> {example: 1}\n */\nconst $ = (...args) => {\n  return cacheSuper(...args);\n};\n/**\n * Re-assigns the main method for $.\n *\n * @function superMethod\n * @memberof $\n * @param {Function} method - The function that will become the main object's method.\n * @returns {undefined} - Returns nothing.\n *\n * @example\n * superMethod($.get);\n * // -> $('flow', $);\n * // -> $.flow\n */\nconst superMethod = (method) => {\n  cacheSuper = method;\n};\n$.superMethod = superMethod;\nexport default $;\n","import acid from '../namespace/index';\nconst objectNative = Object;\nexport const keys = objectNative.keys;\nexport const is = objectNative.is;\nexport const assign = objectNative.assign;\nexport const getOwnPropertyDescriptor = objectNative.getOwnPropertyDescriptor;\nexport const defineProperty = objectNative.defineProperty;\nexport const getOwnPropertyNames = objectNative.getOwnPropertyNames;\nexport const objectSize = (thisObject) => {\n  return keys(thisObject).length;\n};\nassign(acid, {\n  keys,\n  is,\n  assign,\n  getOwnPropertyDescriptor,\n  defineProperty,\n  getOwnPropertyNames,\n  objectSize\n});\n","import acid from '../namespace/index';\nimport { assign } from '../internal/object';\nexport const asyncEach = async (array, arg) => {\n  const arrayLength = array.length;\n  for (let index = 0; index < arrayLength; index++) {\n    const item = array[index];\n    await item(arg, index, arrayLength);\n  }\n};\nassign(acid, {\n  asyncEach,\n});\n","import acid from '../namespace/index';\nimport { assign } from '../internal/object';\nimport { hasValue } from '../internal/is';\n/**\n  * Iterates based on a start index and an end index. The loop ends when the start index is equal to the end index.\n  *\n  * @function times\n  * @type {Function}\n  * @param {number} startIndex - The number to start loop from.\n  * @param {number} endIndex - The number to stop at the loop.\n  * @param {Function} iteratee - Transformation function which is passed position, start, and end.\n  * @returns {undefined} Nothing.\n  *\n  * @example\n  * times(0, 3, (item) => {\n  *   console.log(item);\n  * });\n  * //Will log\n  * // 0\n  * // 1\n  * // 2\n  * // => undefined\n*/\nexport const times = (startIndex, endIndex, iteratee) => {\n  const start = (startIndex) ? startIndex : 0;\n  const end = (startIndex) ? endIndex : startIndex;\n  const iterateeMethod = iteratee || endIndex;\n  for (let position = start; position < end; position++) {\n    iterateeMethod(position, start, end);\n  }\n};\n/**\n  * IIterates based on a start index and end index. Creates an array with the results of the iteratee on every element in the calling array. The loop ends when the start index is equal to the end index.\n  *\n  * @function timesMap\n  * @category Utility\n  * @type {Function}\n  * @param {number} startIndex - The number to start loop from.\n  * @param {number} endIndex - The number to stop at the loop.\n  * @param {Function} iteratee - Transformation function which is passed position, start, and end.\n  * @param {Array} [results = []] - Array that will be used to assign results.\n  * @returns {Object} An array with iteratee's returned values.\n  *\n  * @example\n  * timesMap(0, 3, (item) => {\n  *   console.log(item);\n  * });\n  * // => [0, 1, 2]\n*/\nexport const timesMap = (startIndex, endIndex, iteratee, results = []) => {\n  const start = (iteratee) ? startIndex : 0;\n  const end = (iteratee) ? endIndex : startIndex;\n  const iterateeMethod = iteratee || endIndex;\n  let result;\n  times(start, end, (position) => {\n    result = iterateeMethod(results, position, start, end);\n    if (hasValue(result)) {\n      results.push(result);\n    }\n  });\n  return results;\n};\n/**\n  * Iterates through the given array.\n  *\n  * @function eachArray\n  * @type {Function}\n  * @param {Array} callingArray - Array that will be looped through.\n  * @param {Function} iteratee - Transformation function which is passed item, index, calling array, and array length.\n  * @returns {Object} The originally given array.\n  *\n  * @example\n  * eachArray([1, 2, 3], (item) => {\n  *   console.log(item);\n  * });\n  * // => [1, 2, 3]\n*/\nexport const eachArray = (callingArray, iteratee) => {\n  const arrayLength = callingArray.length;\n  for (let index = 0; index < arrayLength; index++) {\n    iteratee(callingArray[index], index, callingArray, arrayLength);\n  }\n};\n/**\n  * Iterates through the given array in reverse.\n  *\n  * @function eachArrayRight\n  * @type {Function}\n  * @param {Array} callingArray - Array that will be looped through.\n  * @param {Function} iteratee - Transformation function which is passed item, index, calling array, and array length.\n  * @returns {Object} The originally given array.\n  *\n  * @example\n  * eachArrayRight([1, 2, 3], (item) => {\n  *   console.log(item);\n  * });\n  * // => [3, 2, 1]\n*/\nexport const eachArrayRight = (callingArray, iteratee) => {\n  const arrayLength = callingArray.length;\n  for (let index = arrayLength - 1; index >= 0; index--) {\n    iteratee(callingArray[index], index, callingArray, arrayLength);\n  }\n};\n/**\n  * Iterates through the given array while the iteratee returns true.\n  *\n  * @function eachWhile\n  * @type {Function}\n  * @param {Array} callingArray - Array that will be looped through.\n  * @param {Function} iteratee - Transformation function which is passed item, key, calling array, and array length.\n  * @returns {boolean} Returns the true if all values returned are true or false if one value returns false.\n  *\n  * @example\n  * eachWhile([true, true, false], (item) => {\n  *   console.log(item);\n  *   return item;\n  * });\n  * //true\n  * //true\n  * // => false\n*/\nexport const eachWhile = (callingArray, iteratee) => {\n  const arrayLength = callingArray.length;\n  for (let index = 0; index < arrayLength; index++) {\n    if (iteratee(callingArray[index], index, callingArray, arrayLength) === false) {\n      return false;\n    }\n  }\n  return true;\n};\n/**\n  * Iterates through the calling array and creates an array with all elements that pass the test implemented by the iteratee.\n  *\n  * @function filterArray\n  * @type {Function}\n  * @param {Array} callingArray - Array that will be looped through.\n  * @param {Function} iteratee - Transformation function which is passed item, index, the newly created object, calling array, and array length.\n  * @param {Array} [results = []] - Array that will be used to assign results.\n  * @returns {Object} An array with properties that passed the test.\n  *\n  * @example\n  * filterArray([false, true, true], (item) => {\n  *   return item;\n  * });\n  * // => [true, true]\n*/\nexport const filterArray = (callingArray, iteratee, results = []) => {\n  eachArray(callingArray, (item, index, arrayOriginal, arrayLength) => {\n    if (iteratee(item, index, results, arrayOriginal, arrayLength) === true) {\n      results.push(item);\n    }\n  });\n  return results;\n};\nconst generateMap = (method) => {\n  return (callingArray, iteratee, results = []) => {\n    method(callingArray, (item, index, arrayOriginal, arrayLength) => {\n      results[index] = iteratee(item, index, results, arrayOriginal, arrayLength);\n    });\n    return results;\n  };\n};\n/**\n  * Iterates through the calling array and creates an object with the results of the iteratee on every element in the calling array.\n  *\n  * @function mapArray\n  * @category Utility\n  * @type {Function}\n  * @param {Array} callingArray - Array that will be looped through.\n  * @param {Function} iteratee - Transformation function which is passed item, index, the newly created array, calling array, and array length.\n  * @param {Array} [results = []] - Array that will be used to assign results.\n  * @returns {Object} An array of the same calling array's type.\n  *\n  * @example\n  * mapArray({a: 1, b: 2, c: 3}, (item) => {\n  *   return item * 2;\n  * });\n  * // => {a: 2, b: 4, c: 6}\n*/\nexport const mapArray = generateMap(eachArray);\n/**\n  * Iterates through the calling array and creates an object with the results of the iteratee on every element in the calling array in reverse.\n  *\n  * @function mapArrayRight\n  * @category Utility\n  * @type {Function}\n  * @param {Array} callingArray - Array that will be looped through.\n  * @param {Function} iteratee - Transformation function which is passed item, index, the newly created array, calling array, and array length.\n  * @param {Array} [results = []] - Array that will be used to assign results.\n  * @returns {Object} An array of the same calling array's type.\n  *\n  * @example\n  * mapArrayRight({a: 1, b: 2, c: 3}, (item) => {\n  *   return item * 2;\n  * });\n  * // => {a: 2, b: 4, c: 6}\n*/\nexport const mapArrayRight = generateMap(eachArrayRight);\n/**\n  * Iterates through the calling array and creates an array with the results, (excludes results which are null or undefined), of the iteratee on every element in the calling array.\n  *\n  * @function compactMapArray\n  * @type {Function}\n  * @param {Array} callingArray - Array that will be looped through.\n  * @param {Function} iteratee - Transformation function which is passed item, index, the newly created array, calling array, and array length.\n  * @param {Array} [results = []] - Array that will be used to assign results.\n  * @returns {Object} An array with mapped properties that are not null or undefined.\n  *\n  * @example\n  * compactMapArray([0, 2, 3], (item) => {\n  *   return item * 2;\n  * });\n  * // => [4, 6]\n*/\nexport const compactMapArray = (callingArray, iteratee, results = []) => {\n  eachArray(callingArray, (item, index, arrayOriginal, arrayLength) => {\n    const returned = iteratee(item, index, results, arrayOriginal, arrayLength);\n    if (hasValue(returned)) {\n      results.push(returned);\n    }\n  });\n  return results;\n};\n/**\n  * Iterates through the given and creates an object with all elements that pass the test implemented by the iteratee.\n  *\n  * @function mapWhile\n  * @type {Function}\n  * @param {Array} callingArray - Array that will be looped through.\n  * @param {Function} iteratee - Transformation function which is passed item, index, the newly created array, calling array, and array length.\n  * @param {Array} [results = []] - Array that will be used to assign results.\n  * @returns {Array} An array with properties that passed the test.\n  *\n  * @example\n  * mapWhile({a: false, b: true, c: true}, (item) => {\n  *   return true;\n  * });\n  * // => {b: true, c: true}\n*/\nexport const mapWhile = (callingArray, iteratee, results = []) => {\n  const arrayLength = callingArray.length;\n  for (let index = 0; index < arrayLength; index++) {\n    const returned = iteratee(callingArray[index], index, results, callingArray, arrayLength);\n    if (!returned) {\n      break;\n    }\n    results[index] = returned;\n  }\n  return results;\n};\nassign(acid, {\n  compactMapArray,\n  eachArray,\n  eachArrayRight,\n  eachWhile,\n  filterArray,\n  mapArray,\n  mapArrayRight,\n  mapWhile,\n  times,\n  timesMap,\n});\n","import acid from '../namespace/index';\nimport { eachArray } from '../array/each';\nimport { assign, objectSize } from './object';\nexport const objectStringGenerate = (objectName) => {\n  return `[object ${objectName}]`;\n};\nexport const isUndefined = function(obj) {\n  return obj === undefined;\n};\nexport const isNull = (obj) => {\n  return obj === null;\n};\nexport const hasValue = (item) => {\n  return !isUndefined(item) && !isNull(item);\n};\nexport const isSameObjectGenerator = (type) => {\n  return (obj) => {\n    return (hasValue(obj)) ? obj.toString() === type : false;\n  };\n};\nexport const isConstructor = (nativeObject) => {\n  return (obj) => {\n    return (hasValue(obj)) ? obj.constructor === nativeObject : false;\n  };\n};\nexport const decimalCheck = /\\.|\\+/;\nexport const isDecimal = (string) => {\n  return string.toString().match(decimalCheck);\n};\nexport const isArray = Array.isArray;\nexport const isString = isConstructor(String);\nexport const isNumber = isConstructor(Number);\nexport const isPlainObject = (obj) => {\n  if (hasValue(obj)) {\n    return obj.constructor.toString().trim()\n      .slice(9, 16) === 'Object(';\n  }\n  return false;\n};\nexport const isFunction = (obj) => {\n  return (hasValue(obj)) ? obj instanceof Function : false;\n};\nexport const has = (string, ...search) => {\n  return string.includes(...search);\n};\nexport const hasLength = (obj) => {\n  return Boolean(obj.length);\n};\nexport const isEmpty = (obj) => {\n  if (isString(obj) || isArray(obj)) {\n    return !hasLength(obj);\n  } else if (isPlainObject(obj)) {\n    return !objectSize(obj);\n  }\n  return !hasValue(obj);\n};\nexport const regexGenerator = (regexType) => {\n  return (item) => {\n    return (hasValue(item)) ? regexType.test(item) : false;\n  };\n};\nexport const isFileCSS = regexGenerator(/\\.css$/);\nexport const isFileJSON = regexGenerator(/\\.json$/);\nexport const isFileJS = regexGenerator(/\\.js$/);\nexport const hasDot = regexGenerator(/\\./);\nexport const getExtensionRegex = /\\.([0-9a-z]+)/;\nexport const getFileExtension = (string) => {\n  return string.match(getExtensionRegex);\n};\nconst nativeObjectNames = ['RegExp', 'Arguments', 'Boolean', 'Date', 'Error', 'Map', 'Object', 'Set', 'WeakMap',\n  'ArrayBuffer', 'Float32Array', 'Float64Array', 'Int8Array', 'Int16Array', 'Int32Array',\n  'Uint8Array', 'Uint8ClampedArray',\n  'Uint16Array', 'Uint32Array'];\neachArray(nativeObjectNames, (item) => {\n  acid[`is${item}`] = isSameObjectGenerator(objectStringGenerate(item));\n});\nassign(acid, {\n  getFileExtension,\n  has,\n  hasLength,\n  hasValue,\n  isArray,\n  isDecimal,\n  isEmpty,\n  isFileCSS,\n  isFileJS,\n  isFileJSON,\n  isFunction,\n  isNull,\n  isNumber,\n  isPlainObject,\n  isString,\n  isUndefined,\n});\n","import acid from '../namespace/index';\nimport { assign } from '../internal/object';\nimport { isArray } from '../internal/is';\nexport const ensureArray = (object) => {\n  return (isArray(object)) ? object : [object];\n};\nassign(acid, {\n  ensureArray\n});\n","import acid from '../namespace/index';\nimport { assign } from '../internal/object';\nimport { ensureArray } from '../array/ensure';\nimport { isArray } from '../internal/is';\n// Flattens a nested array. Pass level to flatten up to a depth;\nexport const flatten = (arrayArg, level = 1) => {\n  let array = arrayArg;\n  for (let i = 0; i < level; i++) {\n    array = array.reduce((previousValue, currentValue) => {\n      return previousValue.concat(ensureArray(currentValue));\n    }, []);\n  }\n  return array;\n};\nexport const flattenDeep = (array) => {\n  return array.reduce((previousValue, currentValue) => {\n    return previousValue.concat((isArray(currentValue)) ? flatten(currentValue) : currentValue);\n  }, []);\n};\nassign(acid, {\n  flatten,\n  flattenDeep,\n});\n","import acid from '../namespace/index';\nimport { assign } from '../internal/object';\nimport { eachArray } from './each';\nimport { ensureArray } from './ensure';\n/**\n * Removes all occurrences of the passed in items from the array and returns the array.\n *\n * @function remove\n * @param {Array} array - Mutated Array without with removed occurrences.\n * @param {Array} removeThese - Items to remove from the array.\n * @returns {Array} The array this method was called on.\n *\n * @example\n * const array = [1, 2, 3, 3, 4, 3, 5];\n *\n * remove(array,1);\n * // -> [2, 3, 3, 4, 3, 5]\n *\n * remove(array,3);\n * // -> [2, 4, 5]\n *\n * remove(array,[2, 5]);\n * // -> [4]\n */\nexport const remove = (array, removeThese) => {\n  const removeTheseArray = ensureArray(removeThese);\n  eachArray(array, (item) => {\n    if (removeTheseArray.includes(item)) {\n      array.splice(array, removeTheseArray.indexOf(item), 1);\n    }\n  });\n  return array;\n};\nassign(acid, {\n  remove\n});\n","import acid from '../namespace/index';\nimport { assign } from '../internal/object';\nexport const chunk = (array, size = 1) => {\n  const chunked = [];\n  let index = 0;\n  array.forEach((item, key) => {\n    if (!(key % size)) {\n      chunked.push([]);\n      if (key) {\n        index++;\n      }\n    }\n    chunked[index].push(item);\n  });\n  return chunked;\n};\nassign(acid, {\n  chunk,\n});\n","import acid from '../namespace/index';\nimport { assign } from '../internal/object';\nimport { eachArray, eachArrayRight } from './each';\nimport { hasValue } from '../internal/is';\nconst returnFlow = (method) => {\n  return (...funcs) => {\n    return (arg) => {\n      let value;\n      method(funcs, (item) => {\n        const temp = (hasValue(value)) ? value : arg;\n        value = item(temp);\n      });\n      return value;\n    };\n  };\n};\n// Returns the composition of a list of functions, where each function consumes the return value of the function that follows. In math terms, composing the functions f(), g(), and h() produces f(g(h())).\nexport const flow = returnFlow(eachArray);\n// Returns the composition of a list of functions, where each function consumes the return value of the function that follows. In math terms, composing the functions f(), g(), and h() produces f(g(h())).\nexport const flowRight = returnFlow(eachArrayRight);\nassign(acid, {\n  flow,\n  flowRight,\n});\n","import acid from '../namespace/index';\nimport { assign } from '../internal/object';\nexport const rest = (array) => {\n  return array.slice(1, array.length - 1);\n};\nassign(acid, {\n  rest\n});\n","import acid from '../namespace/index';\nimport { assign } from '../internal/object';\nexport const clear = (array) => {\n  array.length = 0;\n  return array;\n};\nassign(acid, {\n  clear,\n});\n","import acid from '../namespace/index';\nimport { assign } from '../internal/object';\nimport { eachArray } from './each';\nexport const arraySortToObject = (func, array, sortedObject = {}) => {\n  eachArray(array, (item, key) => {\n    func(item, key, sortedObject);\n  });\n  return sortedObject;\n};\nassign(acid, {\n  arraySortToObject\n});\n","import acid from '../namespace/index';\nimport { assign } from '../internal/object';\nimport { arraySortToObject } from './sortToObject';\nexport const groupBy = (array, funct) => {\n  return arraySortToObject((item, index, objectArg) => {\n    const results = funct(item);\n    if (!objectArg[results]) {\n      objectArg[results] = [];\n    }\n    objectArg[results].push(item);\n  }, array);\n};\nassign(acid, {\n  groupBy\n});\n","import acid from '../namespace/index';\nimport { assign } from '../internal/object';\n// start from end array using amount as index\nexport const right = (array, amount) => {\n  return array[array.length - 1 - amount];\n};\nassign(acid, {\n  right\n});\n","import acid from '../namespace/index';\nimport { assign } from '../internal/object';\nexport const cloneArray = (array) => {\n  return array.splice();\n};\nassign(acid, {\n  cloneArray\n});\n","import acid from '../namespace/index';\nimport { assign } from '../internal/object';\nconst mathNative = Math;\nconst floorMethod = mathNative.floor;\nconst randomMethod = mathNative.random;\n/**\n  * Adds two numbers.\n  *\n  * @function add\n  * @type {Function}\n  * @param {number} number - First number.\n  * @param {number} value - Second number.\n  * @returns {number} - Returns the sum of the arguments.\n  *\n  * @example\n  * add(1, 1);\n  * // => 2\n*/\nexport const add = (number, value) => {\n  return number + value;\n};\n/**\n  * Subtracts two numbers.\n  *\n  * @function minus\n  * @type {Function}\n  * @param {number} number - First number.\n  * @param {number} value - Second number.\n  * @returns {number} - Returns the difference of the arguments.\n  *\n  * @example\n  * minus(1, 1);\n  * // => 0\n*/\nexport const minus = (number, value) => {\n  return number - value;\n};\n/**\n  * Divides two numbers.\n  *\n  * @function divide\n  * @type {Function}\n  * @param {number} number - First number.\n  * @param {number} value - Second number.\n  * @returns {number} - Returns the quotient of the arguments.\n  *\n  * @example\n  * divide(10, 5);\n  * // => 2\n*/\nexport const divide = (number, value) => {\n  return number / value;\n};\n/**\n  * Multiplies two numbers.\n  *\n  * @function multiply\n  * @type {Function}\n  * @param {number} number - First number.\n  * @param {number} value - Second number.\n  * @returns {number} - Returns the product of the arguments.\n  *\n  * @example\n  * multiply(10, 5);\n  * // => 50\n*/\nexport const multiply = (number, value) => {\n  return number * value;\n};\n/**\n  *  Extracts the remainder between two numbers.\n  *\n  * @function remainder\n  * @type {Function}\n  * @param {number} number - First number.\n  * @param {number} value - Second number.\n  * @returns {number} - Returns the remainder of the arguments.\n  *\n  * @example\n  * remainder(10, 6);\n  * // => 4\n*/\nexport const remainder = (number, value) => {\n  return number % value;\n};\n/**\n  *  Increments a number.\n  *\n  * @function increment\n  * @type {Function}\n  * @param {number} number - First number.\n  * @returns {number} - Returns an incremented version of the number.\n  *\n  * @example\n  * increment(10);\n  * // => 11\n*/\nexport const increment = (number) => {\n  return number + 1;\n};\n/**\n  *  Decrements a number.\n  *\n  * @function deduct\n  * @type {Function}\n  * @param {number} number - First number.\n  * @returns {number} - Returns a decremented version of the number.\n  *\n  * @example\n  * deduct(10);\n  * // => 9\n*/\nexport const deduct = (number) => {\n  return number - 1;\n};\n/**\n  *  Produces a random number between min (included) and max (excluded).\n  *\n  * @function randomArbitrary\n  * @type {Function}\n  * @param {number} max - Establishes highest possible value for the random number.\n  * @param {number} [min = 0] - Establishes lowest possible value for the random number.\n  * @returns {number} - Returns random integer between the max and min range.\n  *\n  * @example\n  * randomArbitrary(10);\n  * // => 9.1\n*/\nexport const randomArbitrary = (max, min = 0) => {\n  return randomMethod() * (max - min) + min;\n};\n/**\n  *  Produces a random integer between min (included) and max (excluded).\n  *\n  * @function randomInt\n  * @type {Function}\n  * @param {number} max - Establishes highest possible value for the random number.\n  * @param {number} [min = 0] - Establishes lowest possible value for the random number.\n  * @returns {number} - Returns random integer between the max and min range.\n  *\n  * @example\n  * randomInt(10);\n  * // => 9\n*/\nexport const randomInt = (max, min = 0) => {\n  return floorMethod(randomMethod() * (max - min)) + min;\n};\nassign(acid, {\n  add,\n  deduct,\n  divide,\n  increment,\n  minus,\n  multiply,\n  randomArbitrary,\n  randomInt,\n  remainder,\n});\n","import acid from '../namespace/index';\nimport { assign } from '../internal/object';\nimport { randomInt } from '../number/math';\n/*\n  Produce a random sample from the list. Pass a number to return n random elements from the list. Otherwise a single random item will be returned.\n  sample([1,2,3,4] , 2);\n*/\nexport const sample = (array, amount = 1) => {\n  if (amount === 1) {\n    return array[randomInt(array.length - 1, 0)];\n  }\n  const sampleArray = [];\n  const used = {};\n  let count = 0;\n  let index;\n  while (count < amount) {\n    index = randomInt(array.length - 1, 0);\n    if (!used[index]) {\n      sampleArray.push(sampleArray[index]);\n      used[index] = true;\n      count++;\n    }\n  }\n  return sampleArray;\n};\nassign(acid, {\n  sample\n});\n","import acid from '../namespace/index';\nimport { assign } from '../internal/object';\nimport { isString } from '../internal/is';\nexport const compact = (array) => {\n  return array.filter((item) => {\n    return isString(item) && !item.length ? false : item;\n  });\n};\nassign(acid, {\n  compact,\n});\n","import acid from '../namespace/index';\nimport { assign } from '../internal/object';\nimport { arraySortToObject } from './sortToObject';\n// Given a list, and an iteratee function that returns a key for each element in the list (or a property name), returns an object with an index of each item. Just like groupBy, but for when you know your keys are unique.\nexport const indexBy = (array, index) => {\n  return arraySortToObject((item, key, object) => {\n    object[item[index]] = item;\n  }, array);\n};\nassign(acid, {\n  indexBy\n});\n","import acid from '../namespace/index';\nimport { assign } from './object';\nconst arrayNative = Array;\nexport const toArray = arrayNative.from;\nassign(acid, {\n  toArray,\n});\n","import acid from '../namespace/index';\nimport { assign } from '../internal/object';\nimport { toArray } from '../internal/array';\nimport { randomInt } from '../number/math';\n// shuffle an array and return a new array\nexport const shuffle = (array, amount = 1) => {\n  const shuffleArray = toArray(array);\n  let count = 0;\n  let index;\n  let value;\n  while (count < amount) {\n    index = randomInt(shuffleArray.length - 1, 0);\n    value = shuffleArray[count];\n    shuffleArray[count] = shuffleArray[index];\n    shuffleArray[index] = value;\n    count++;\n  }\n  return shuffleArray;\n};\nassign(acid, {\n  shuffle\n});\n","import acid from '../namespace/index';\nimport { assign } from '../internal/object';\nimport { eachArray } from './each';\nexport const countBy = (array, funct) => {\n  const object = {};\n  let result;\n  eachArray(array, (item) => {\n    result = funct(item);\n    if (!object[result]) {\n      object[result] = 0;\n    }\n    object[result]++;\n  });\n  return object;\n};\nexport const countKey = (array, keyName) => {\n  let count = 0;\n  eachArray(array, (item) => {\n    if (item[keyName]) {\n      count++;\n    }\n  });\n  return count;\n};\nexport const countNoKey = (array, keyName) => {\n  let count = 0;\n  eachArray(array, (item) => {\n    if (!item[keyName]) {\n      count++;\n    }\n  });\n  return count;\n};\nassign(acid, {\n  countBy,\n  countKey,\n  countNoKey\n});\n","import acid from '../namespace/index';\nimport { assign } from '../internal/object';\nexport const initial = (array) => {\n  return array.slice(0, array.length - 1);\n};\nassign(acid, {\n  initial\n});\n","import acid from '../namespace/index';\nimport { assign } from '../internal/object';\nconst mathNativeMin = Math.min;\n// get smallest number from array\nexport const smallest = (array) => {\n  return mathNativeMin(...array);\n};\nassign(acid, {\n  smallest\n});\n","import acid from '../namespace/index';\nimport { assign } from '../internal/object';\nconst rangeUp = (start, end, increment) => {\n  const rangeArray = [];\n  let position = start;\n  while (position < end) {\n    rangeArray.push(position);\n    position += increment;\n  }\n  return rangeArray;\n};\nconst rangeDown = (start, end, incrementArg) => {\n  const increment = (incrementArg < 0) ? incrementArg * -1 : incrementArg;\n  const rangeArray = [];\n  let position = start;\n  while (position < end) {\n    rangeArray.push(position);\n    position -= increment;\n  }\n  return rangeArray;\n};\nexport const range = (start, end, increment = 1) => {\n  if (start < end) {\n    return rangeUp(start, end, increment);\n  } else {\n    return rangeDown(start, end, increment);\n  }\n};\nexport const rangeRight = (start, end, increment = 1) => {\n  return rangeDown(end, start, increment);\n};\nassign(acid, {\n  range,\n  rangeRight\n});\n","import acid from '../namespace/index';\nimport { assign } from '../internal/object';\nimport { eachWhile, compactMapArray } from './each';\n/**\n * Returns an new array that is the [set intersection](http://en.wikipedia.org/wiki/Intersection_(set_theory))\n * of the array and the input array(s).\n *\n * @function intersect\n * @param {Array} array - Array to compare other arrays to.\n * @param {...Array} arrays - A variable number of arrays.\n * @returns {Array} The new array of unique values shared by all of the arrays.\n *\n * @example\n * intersect([1, 2, 3], [2, 3, 4]);\n * // -> [2, 3]\n *\n * intersect([1, 2, 3], [101, 2, 50, 1], [2, 1]);\n * // -> [1, 2]\n */\nexport const intersect = (array, ...arrays) => {\n  let yes;\n  return compactMapArray(array, (item) => {\n    yes = true;\n    eachWhile(arrays, (otherItem) => {\n      if (!otherItem.includes(item)) {\n        yes = false;\n      }\n      return yes;\n    });\n    if (yes) {\n      return item;\n    }\n  });\n};\nassign(acid, {\n  intersect\n});\n","import acid from '../namespace/index';\nimport { assign } from '../internal/object';\n/*\n\tPerform alphabetical sort on collection on provided key name\n*/\nexport const sortAlpha = (collection, key) => {\n  let currentKey;\n  let nextKey;\n  collection.sort((current, next) => {\n    currentKey = current[key];\n    nextKey = next[key];\n    if (currentKey < nextKey) {\n      return -1;\n    } else if (currentKey > nextKey) {\n      return 1;\n    }\n    return 0;\n  });\n  return collection;\n};\nassign(acid, {\n  sortAlpha\n});\n","import acid from '../namespace/index';\nimport { assign } from '../internal/object';\nimport { compactMapArray } from './each';\nexport const difference = (array, compare) => {\n  return compactMapArray(array, (item) => {\n    if (!compare.includes(item)) {\n      return item;\n    }\n  });\n};\nassign(acid, {\n  difference\n});\n","import acid from '../namespace/index';\nimport { assign } from '../internal/object';\nimport { mapArray } from './each';\n// Calls the method named by methodName on each value in the list. Any extra arguments passed to invoke will be forwarded on to the method invocation.\nconst invoke = (array, methodName, args) => {\n  return mapArray(array, (item) => {\n    return item[methodName](...args);\n  });\n};\nassign(acid, {\n  invoke\n});\n","import acid from '../namespace/index';\nimport { assign } from '../internal/object';\nexport const drop = (array, amount, arrayLength = array.length) => {\n  return array.splice(amount, arrayLength);\n};\nexport const dropRight = (array, amount) => {\n  return drop(array, 0, array.length - amount);\n};\nassign(acid, {\n  drop,\n  dropRight\n});\n","import acid from '../namespace/index';\nimport { assign } from '../internal/object';\nimport { eachWhile } from './each';\n/**\n   * Performs a shallow strict comparison between two objects.\n   *\n   * @function isMatchArray\n   * @type {Function}\n   * @param {Array} source - Source object.\n   * @param {Array} compareArray - Object to compare to source.\n   * @returns {boolean} Returns the true or false.\n   *\n   * @example\n   * isMatchArray([1,2,3], [1,2,3]);\n   * // => true\n */\nexport const isMatchArray = (source, compareArray) => {\n  if (compareArray.length === source.length) {\n    return eachWhile(source, (item, index) => {\n      return compareArray[index] !== item;\n    });\n  }\n  return false;\n};\nassign(acid, {\n  isMatchArray,\n});\n","import acid from '../namespace/index';\nimport { assign } from '../internal/object';\nimport { eachArray } from './each';\n// Uses a binary search to determine the index at which the value should be inserted into the list in order to maintain the list's sorted order.\nconst sortedIndex = (array, n) => {\n  let min = 0;\n  eachArray(array, (item, index) => {\n    if (n > item) {\n      min = index;\n    }\n  });\n  if (min > 0) {\n    min = min + 1;\n  }\n  return min;\n};\nassign(acid, {\n  sortedIndex\n});\n","import acid from '../namespace/index';\nimport { assign } from '../internal/object';\n// get largest number from array\nconst mathNativeMax = Math.max;\nexport const largest = (array) => {\n  return mathNativeMax(...array);\n};\nassign(acid, {\n  largest\n});\n","import acid from '../namespace/index';\nimport { assign } from '../internal/object';\nimport { eachArray } from './each';\nconst sumOf = (array, resultArg = 0) => {\n  let result = resultArg;\n  let item;\n  eachArray(array, (itemArg) => {\n    item = itemArg;\n    if (item) {\n      result = result + Number(item);\n    }\n  });\n  return result;\n};\nassign(acid, {\n  sumOf\n});\n","import acid from '../namespace/index';\nimport { assign } from '../internal/object';\n/*\n  const array = [async function(...args){\n    console.log(1,args);\n  }, async function(...args){\n    console.log(2,args);\n  }];\n  acid.asyncEach(array,[3,4]);\n*/\nexport const eachAsync = async (array, funct) => {\n  const arrayLength = array.length;\n  for (let index = 0; index < arrayLength; index++) {\n    await funct(array[index], index, arrayLength);\n  }\n};\nassign(acid, {\n  eachAsync,\n});\n","import acid from '../namespace/index';\nimport { assign } from '../internal/object';\n// Returns the last element of an array. Passing n will return the last n elements of the array.\nexport const last = (array, indexFrom) => {\n  const arrayLength = array.length;\n  return (indexFrom) ? array.slice(arrayLength - indexFrom, arrayLength) : array[arrayLength - 1];\n};\nassign(acid, {\n  last\n});\n","import acid from '../namespace/index';\nimport { assign } from '../internal/object';\nexport const take = (array, amount) => {\n  return array.slice(0, amount);\n};\nexport const takeRight = (array, amount) => {\n  return array.slice(array.length - amount, amount);\n};\nassign(acid, {\n  take,\n  takeRight\n});\n","import acid from '../namespace/index';\nimport { assign } from '../internal/object';\nimport { eachAsync } from './eachAsync';\nexport const mapAsync = async (array, iteratee) => {\n  const results = [];\n  await eachAsync(array, async (item, index, arrayLength) => {\n    results[index] = await iteratee(item, index, arrayLength);\n  });\n  return results;\n};\nassign(acid, {\n  mapAsync,\n});\n","import acid from '../namespace/index';\nimport { assign } from '../internal/object';\nconst onlyUnique = (value, index, array) => {\n  return array.indexOf(value) === index;\n};\nconst sortUnique = (item, index, array) => {\n  return item !== array[index - 1];\n};\nexport const unique = (array, isSorted) => {\n  if (isSorted) {\n    return array.filter(sortUnique);\n  }\n  return array.filter(onlyUnique);\n};\nassign(acid, {\n  unique\n});\n","import acid from '../namespace/index';\nimport { assign } from '../internal/object';\nimport { eachArray } from './each';\nimport { unique } from './unique';\n// Computes the union of the passed-in arrays: the list of unique items, in order, that are present in one or more of the arrays.\nexport const union = (...args) => {\n  const result = [];\n  eachArray(args, (array) => {\n    eachArray(unique(array), (item) => {\n      if (result.includes(item)) {\n        result.push(item);\n      }\n    });\n  });\n  return result;\n};\nassign(acid, {\n  union\n});\n","import acid from '../namespace/index';\nimport { assign } from '../internal/object';\nimport { eachAsync } from './eachAsync';\nimport { hasValue } from '../internal/is';\nexport const compactMapAsync = async (array, funct) => {\n  const results = [];\n  let result;\n  await eachAsync(array, async (item, index, arrayLength) => {\n    result = await funct(item, index, arrayLength);\n    if (hasValue(result)) {\n      results.push(result);\n    }\n  });\n  return results;\n};\nassign(acid, {\n  compactMapAsync,\n});\n","import acid from '../namespace/index';\nimport { assign } from '../internal/object';\nexport const numericalCompare = (a, b) => {\n  return a - b;\n};\n/**\n  * Sorts an array in place using a numerical comparison algorithm from lowest to highest.\n  *\n  * @function numSort\n  * @type {Function}\n  * @param {Array} numberList - List of numbers.\n  * @returns {Array} The array this method was called on.\n  *\n  * @example\n  * numSort([10, 0, 2, 1]);\n  * // -> [0, 1, 2, 10]\n */\nexport const numSort = (numberList) => {\n  return numberList.sort(numericalCompare);\n};\nassign(acid, {\n  numSort\n});\n","import acid from '../namespace/index';\nimport { assign } from '../internal/object';\nexport const findDifference = (array, sum) => {\n  const returnedObject = {};\n  const arrayLength = array.length;\n  let item;\n  let end;\n  let check;\n  for (let index = 0; index < arrayLength; index++) {\n    item = array[index];\n    end = sum - item;\n    check = array.indexOf(end);\n    if (check !== -1 && check !== index) {\n      returnedObject.start = item;\n      returnedObject.end = end;\n      returnedObject.startIndex = index;\n      returnedObject.endIndex = check;\n      break;\n    }\n  }\n  return returnedObject;\n};\nassign(acid, {\n  findDifference\n});\n","import acid from '../namespace/index';\nimport { assign } from '../internal/object';\nimport { arraySortToObject } from './sortToObject';\n// Converts arrays into objects.\nexport const arrayToObject = (values, keys) => {\n  return arraySortToObject((item, index, objectArg) => {\n    objectArg[keys[index]] = item;\n  }, values);\n};\nassign(acid, {\n  arrayToObject\n});\n","import acid from '../namespace/index';\nimport { assign } from '../internal/object';\n// Returns a copy of the array with all instances of the values removed.\nconst without = (array, ...args) => {\n  return array.filter((item) => {\n    return !args.includes(item);\n  });\n};\nassign(acid, {\n  without\n});\n","import acid from '../namespace/index';\nimport { assign } from '../internal/object';\nconst findIndexCache = (element, index, array, indexMatch, propertyName) => {\n  if (element[propertyName] === indexMatch) {\n    return true;\n  }\n};\nexport const findItem = (array, indexMatch, propertyName = 'id') => {\n  const result = array.find((element, index) => {\n    return findIndexCache(element, index, array, indexMatch, propertyName);\n  });\n  return (result === -1) ? false : result;\n};\nexport const findIndex = (array, indexMatch, propertyName = 'id') => {\n  const result = array.findIndex((element, index) => {\n    return findIndexCache(element, index, array, indexMatch, propertyName);\n  });\n  return (result === -1) ? false : result;\n};\nassign(acid, {\n  findItem,\n  findIndex\n});\n","import acid from '../namespace/index';\nimport { assign } from '../internal/object';\nimport { compactMapArray } from './each';\n// Split array into two arrays: one whose elements all satisfy predicate and one whose elements all do not satisfy predicate.\nexport const partition = (array, funct) => {\n  const failed = [];\n  return [\n    compactMapArray(array, (item) => {\n      if (funct(item)) {\n        return item;\n      }\n      failed.push(item);\n    }),\n    failed\n  ];\n};\nassign(acid, {\n  partition\n});\n","import acid from '../namespace/index';\nimport { assign } from '../internal/object';\nimport { eachArray } from './each';\nimport { unique } from './unique';\n// Creates an array that is the symmetric difference of the provided arrays. See Wikipedia for more details.\nexport const xor = (others) => {\n  const xored = [];\n  eachArray(others, (array) => {\n    eachArray(unique(array), (item) => {\n      if (xored.includes(item)) {\n        xored.splice(xored.indexOf(item), 1);\n      } else {\n        xored.push(item);\n      }\n    });\n  });\n  return xored;\n};\nassign(acid, {\n  xor\n});\n","import acid from '../namespace/index';\nimport { assign } from '../internal/object';\nexport const findSum = (array, sum) => {\n  const returnedObject = {};\n  const arrayLength = array.length;\n  let item;\n  let end;\n  let check;\n  for (let index = 0; index < arrayLength; index++) {\n    item = array[index];\n    end = sum - item;\n    check = array.indexOf(end);\n    if (check !== -1 && check !== index) {\n      returnedObject.start = item;\n      returnedObject.end = end;\n      returnedObject.startIndex = index;\n      returnedObject.endIndex = check;\n      break;\n    }\n  }\n  return returnedObject;\n};\nassign(acid, {\n  findSum\n});\n","import acid from '../namespace/index';\nimport { assign } from '../internal/object';\nimport { isArray } from '../internal/is';\nimport { arraySortToObject } from './sortToObject';\nimport { mapArray } from './each';\n// Pluck an attribute from each object in an array.\nexport const pluck = (array, pluckThis) => {\n  let pluckMethod;\n  if (isArray(pluckThis)) {\n    pluckMethod = (item) => {\n      return arraySortToObject((pluckItem, pluckKey, object) => {\n        object[pluckItem] = item[pluckItem];\n      }, pluckThis);\n    };\n  } else {\n    pluckMethod = (item) => {\n      const result = item[pluckThis];\n      return result;\n    };\n  }\n  return mapArray(array, pluckMethod);\n};\nassign(acid, {\n  pluck\n});\n","import acid from '../namespace/index';\nimport { assign } from '../internal/object';\n// Merges together the values of each of the arrays with the values at the corresponding position.\nexport const zip = (...args) => {\n  return args[0].map((item, index) => {\n    return args.map((array) => {\n      return array[index];\n    });\n  });\n};\n// unzip the array of zipped arrays [[\"fred\",30,true],[\"barney\",40,false]]\nexport const unZip = (array) => {\n  return array[0].map((item, index) => {\n    return array.map((arraySet) => {\n      return arraySet[index];\n    });\n  });\n};\nassign(acid, {\n  zip,\n  unZip\n});\n","import acid from '../namespace/index';\nimport { assign } from '../internal/object';\nexport const first = (array, upTo) => {\n  return (upTo) ? array.slice(0, upTo) : array[0];\n};\nassign(acid, {\n  first\n});\n","import acid from '../namespace/index';\nimport { assign } from '../internal/object';\nexport const numericalCompareReverse = (a, b) => {\n  return b - a;\n};\n/**\n * Sorts an array in place using a reverse numerical comparison algorithm from highest to lowest.\n *\n * @function rNumSort\n * @param {Array} numberList - List of numbers.\n * @returns {Array} The array this method was called on.\n *\n * @example\n * rNumSort([10, 0, 2, 1]);\n * // -> [10, 2, 1, 0]\n */\nexport const rNumSort = (numberList) => {\n  return numberList.sort(numericalCompareReverse);\n};\nassign(acid, {\n  rNumSort\n});\n","import acid from '../namespace/index';\nimport { eachArray } from '../array/each';\nimport { assign, keys } from '../internal/object';\nconst isAgent = (string) => {\n  return (string) ? isAgent[string] : keys(isAgent);\n};\nlet userAgentNormalized = navigator.userAgent.toLowerCase();\nuserAgentNormalized = userAgentNormalized.replace(/_/g, '.');\nuserAgentNormalized = userAgentNormalized.replace(/[#_,;()]/g, '');\nconst userAgentSplit = userAgentNormalized.split(/ |\\//);\neachArray(userAgentSplit, (item) => {\n  isAgent[item] = true;\n});\nassign(acid, {\n  isAgent\n});\n","import acid from '../namespace/index';\nimport { assign } from '../internal/object';\nexport const\teventAdd = (obj, eventName, func, capture) => {\n  obj.addEventListener(eventName, func, capture);\n  return obj;\n};\nexport const eventRemove = (obj, eventName, func, capture) => {\n  obj.removeEventListener(eventName, func, capture);\n  return obj;\n};\nassign(acid, {\n  eventAdd,\n  eventRemove,\n});\n","import acid from '../namespace/index';\nimport { assign } from '../internal/object';\nexport const isEnter = (eventObject) => {\n  return eventObject.keyCode === 13;\n};\nassign(acid, {\n  isEnter\n});\n","import acid from '../namespace/index';\nimport { assign } from '../internal/object';\nexport const appState = {};\nassign(acid, {\n  appState\n});\n","import acid from '../namespace/index';\nimport { assign } from '../internal/object';\nexport const createFragment = document.createDocumentFragment.bind(document);\nassign(acid, {\n  createFragment\n});\n","export const append = (node, child) => {\n  node.appendChild(child);\n  return node;\n};\n","import acid from '../namespace/index';\nimport { hasValue } from '../internal/is';\nimport { assign, keys } from '../internal/object';\nimport { eachArray, eachWhile } from '../array/each';\n/**\n  * Iterates through the given object.\n  *\n  * @function eachObject\n  * @type {Function}\n  * @param {Object|Function} callingObject - Object that will be looped through.\n  * @param {Function} iteratee - Transformation function which is passed item, key, calling object, key count, and array of keys.\n  * @returns {Object|Function} The originally given object.\n  *\n  * @example\n  * eachObject({a: 1, b: 2, c: 3}, (item) => {\n  *   console.log(item);\n  * });\n  * // => {a: 1, b: 2, c: 3}\n*/\nexport const eachObject = (thisObject, iteratee) => {\n  const objectKeys = keys(thisObject);\n  eachArray(objectKeys, (key, index, array, propertyCount) => {\n    iteratee(thisObject[key], key, thisObject, propertyCount, objectKeys);\n  });\n};\n/**\n* Iterates through the given object while the iteratee returns true.\n*\n* @function whileObject\n* @type {Function}\n* @param {Object} callingObject - Object that will be looped through.\n* @param {Function} iteratee - Transformation function which is passed item, key, calling array, and array length.\n* @returns {boolean} Returns the true if all values returned are true or false if one value returns false.\n  *\n  * @example\n  * whileObject({a: false, b: true, c: true}, (item) => {\n  *   return item;\n  *  });\n  * // => false\n*/\nexport const whileObject = (callingObject, iteratee, results = {}) => {\n  return eachWhile(callingObject, (item, key, thisObject, propertyCount, objectKeys) => {\n    return iteratee(item, key, results, thisObject, propertyCount, objectKeys);\n  });\n};\n/**\n  * Iterates through the calling object and creates an object with all elements that pass the test implemented by the iteratee.\n  *\n  * @function filterObject\n  * @type {Function}\n  * @param {Object|Function} callingObject - Object that will be looped through.\n  * @param {Function} iteratee - Transformation function which is passed item, key, the newly created object, calling object, key count, and array of keys.\n  * @param {Object|Function} [results = {}] - Object that will be used to assign results.\n  * @returns {Object|Function} An object with properties that passed the test.\n  *\n  * @example\n  * filterObject({a: false, b: true, c: true}, (item) => {\n  *   return true;\n  * });\n  * // => {b: true, c: true}\n*/\nexport const filterObject = (object, iteratee, results = {}) => {\n  eachObject(object, (item, key, thisObject, propertyCount, objectKeys) => {\n    if (iteratee(item, key, results, thisObject, propertyCount, objectKeys) === true) {\n      results[key] = item;\n    }\n  });\n  return results;\n};\n/**\n  * Iterates through the calling object and creates an object with the results of the iteratee on every element in the calling object.\n  *\n  * @function mapObject\n  * @category Utility\n  * @type {Function}\n  * @param {Object|Function} callingObject - Object that will be looped through.\n  * @param {Function} iteratee - Transformation function which is passed item, key, the newly created object, calling object, key count, and array of keys.\n  * @param {Object|Function} [results = {}] - Object that will be used to assign results.\n  * @returns {Object|Function} An object of the same calling object's type.\n  *\n  * @example\n  * mapObject({a: 1, b: 2, c: 3}, (item) => {\n  *   return item * 2;\n  * });\n  * // => {a: 2, b: 4, c: 6}\n*/\nexport const mapObject = (object, iteratee, results = {}) => {\n  eachObject(object, (item, key, thisObject, propertyCount, objectKeys) => {\n    results[key] = iteratee(item, key, results, thisObject, propertyCount, objectKeys);\n  });\n  return results;\n};\n/**\n  * Iterates through the calling object and creates an object with the results, (excludes results which are null or undefined), of the iteratee on every element in the calling object.\n  *\n  * @function compactMapObject\n  * @type {Function}\n  * @param {Object|Function} callingObject - Object that will be looped through.\n  * @param {Function} iteratee - Transformation function which is passed item, key, the newly created object, calling object, key count, and array of keys.\n  * @param {Object|Function} [results = {}] - Object that will be used to assign results.\n  * @returns {Object|Function} An object with mapped properties that are not null or undefined.\n  *\n  * @example\n  * compactMapObject({a: 0, b: 2, c: 3}, (item) => {\n  *   return item * 2;\n  * });\n  * // => {b: 4, c: 6}\n*/\nexport const compactMapObject = (object, iteratee, results = {}) => {\n  eachObject(object, (item, key, thisObject, propertyCount, objectKeys) => {\n    const result = iteratee(item, key, results, propertyCount, objectKeys);\n    if (hasValue(result)) {\n      results[key] = result;\n    }\n  });\n  return results;\n};\nassign(acid, {\n  compactMapObject,\n  eachObject,\n  filterObject,\n  mapObject,\n  whileObject,\n});\n","import acid from '../namespace/index';\nimport { assign } from '../internal/object';\nimport { mapObject } from '../object/each';\nimport { hasValue, isPlainObject, isString } from '../internal/is';\nexport const nodeAttribute = (node, keys, value) => {\n  let results;\n  if (isString(keys)) {\n    if (hasValue(value)) {\n      node.setAttribute(keys, value);\n    } else {\n      return node.getAttribute(keys);\n    }\n  } else if (isPlainObject(keys)) {\n    results = mapObject(keys, (item, key) => {\n      return nodeAttribute(node, key, item);\n    });\n    if (value) {\n      return results;\n    }\n  }\n  return node;\n};\nassign(acid, {\n  nodeAttribute\n});\n","import acid from '../namespace/index';\nimport { assign } from '../internal/object';\n/**\n  * A wrapper around the promise constructor.\n  *\n  * @function promise\n  * @type {Function}\n  * @param {Function} callback - Function to be called back.\n  * @returns {Object} - A constructor with a callback function.\n  *\n  * @example\n  * promise((a) => {});\n  * //=> promise((a) => {})\n*/\nexport const promise = (callback) => {\n  return new Promise(callback);\n};\nassign(acid, {\n  promise\n});\n","import acid from '../namespace/index';\nimport { assign } from '../internal/object';\n/**\n  * Inserts text into a string at a given position.\n  *\n  * @function insertInRange\n  * @type {Function}\n  * @param {string} string - String to insert the text into.\n  * @param {number} index - Point of insertion.\n  * @param {string} text - The string to be inserted.\n  * @returns {string} - The string with the text inserted at the given point.\n  *\n  * @example\n  * insertInRange('A from Lucy.', 1, ' tab');\n  * // => A tab from Lucy.\n*/\nexport const insertInRange = (string, index, text) => {\n  return string.slice(0, index) + text + string.slice(index, string.length);\n};\n/**\n  * Plucks a letter using the index starting from the right.\n  *\n  * @function rightString\n  * @type {Function}\n  * @param {string} string - String to extract the letter from.\n  * @param {number} [index=1] - The starting position.\n  * @returns {string} - A letter at the given index.\n  *\n  * @example\n  * rightString('rightString');\n  * // => g\n  *\n  * rightString('rightString', 2);\n  * // => n\n*/\nexport const rightString = (string, index = 1) => {\n  return string[string.length - index];\n};\n/**\n  * Splits up a string into chunks.\n  *\n  * @function chunkString\n  * @type {Function}\n  * @param {string} string - String to chunked.\n  * @param {number} [size] - The max string length per chunk.\n  * @returns {Array} - An array with strings that are <= size parameter.\n  *\n  * @example\n  * chunkString('chunk', 2);\n  * //-> ['ch', 'un', 'k']\n*/\nexport const chunkString = (string, size) => {\n  return string.match(new RegExp(`(.|[\\r\\n]){1, ${size}}`, 'g'));\n};\n/**\n  * Truncates everything before the index starting from the right.\n  *\n  * @function initialString\n  * @type {Function}\n  * @param {string} string - String to extract the initial letters from.\n  * @param {number} [index=1] - Starting point from the right.\n  * @returns {string} A string with the characters before the index starting from the right.\n  *\n  * @example\n  * initialString('initialString');\n  * //-> initialStrin\n  *\n  * initialString('initialString', 2);\n  * //-> initialStri\n*/\nexport const initialString = (string, index = 1) => {\n  return string.slice(0, index * -1);\n};\n/**\n  * Truncates everything after a index.\n  *\n  * @function restString\n  * @type {Function}\n  * @param {string} string - String to extract the rest of the letters from.\n  * @param {number} [index=1] - Starting point.\n  * @returns {string} - A string without the characters up-to to the index.\n  *\n  * @example\n  * restString('restString');\n  * //-> estString\n  *\n  * restString('restString', 2);\n  * //-> stString\n*/\nexport const restString = (string, index = 1) => {\n  return string.substr(index);\n};\nassign(acid, {\n  chunkString,\n  initialString,\n  insertInRange,\n  restString,\n  rightString,\n});\n","import acid from '../namespace/index';\nimport { assign } from '../internal/object';\nimport { restString } from '../string/range';\nconst dotString = '.';\nconst poundString = '#';\nconst classTest = /^.[\\w_-]+$/;\nconst tagTest = /^[A-Za-z]+$/;\nconst regexSpace = /\\s/;\nexport const getByClass = document.getElementsByClassName.bind(document);\nexport const getByTag = document.getElementsByTagName.bind(document);\nexport const getById = document.getElementById.bind(document);\nexport const querySelector = document.querySelector.bind(document);\nexport const querySelectorAll = document.querySelectorAll.bind(document);\nexport const selector = (select) => {\n  const firstLetter = select[0];\n  switch (firstLetter) {\n  case poundString:\n    if (!regexSpace.test(select)) {\n      return getById(restString(select));\n    }\n    break;\n  case dotString:\n    if (classTest.test(select)) {\n      return getByClass(restString(select));\n    }\n    break;\n  default:\n    if (tagTest.test(select)) {\n      return getByTag(select);\n    }\n  }\n  return querySelectorAll(select);\n};\nassign(acid, {\n  getByClass,\n  getById,\n  getByTag,\n  querySelector,\n  querySelectorAll,\n  selector\n});\n","import acid from '../namespace/index';\nimport { append } from './append';\nimport { assign } from '../internal/object';\nimport { eventAdd } from './event';\nimport { nodeAttribute } from './attribute';\nimport { promise } from '../utility/promise';\nimport { querySelector } from './selector';\nconst createTag = document.createElement.bind(document);\nconst nodeAttachLoadingEvents = (node) => {\n  return promise((accept, reject) => {\n    eventAdd(node, 'load', accept, true);\n    eventAdd(node, 'error', reject, true);\n    append(querySelector('head'), node);\n  });\n};\nexport const importcss = (url) => {\n  const node = nodeAttribute(createTag('link'), {\n    href: `${url}.css`,\n    rel: 'stylesheet',\n    type: 'text/css',\n  });\n  return nodeAttachLoadingEvents(node);\n};\nexport const importjs = (url) => {\n  const node = nodeAttribute(createTag('script'), {\n    async: '',\n    src: `${url}.js`\n  });\n  return nodeAttachLoadingEvents(node);\n};\nassign(acid, {\n  importcss,\n  importjs,\n});\n","import acid from '../namespace/index';\nimport { assign } from '../internal/object';\nimport { eventAdd } from './event';\nimport { importjs } from './import';\nexport const isDocumentReady = (func) => {\n  const state = document.readyState;\n  const checkStatus = state === 'interactive' || state === 'completed' || state === 'complete';\n  if (checkStatus) {\n    return (func) ? func() : true;\n  }\n  if (func) {\n    eventAdd(document, 'DOMContentLoaded', func);\n  }\n  return false;\n};\nassign(acid, {\n  isDocumentReady\n});\nisDocumentReady(() => {\n  importjs('index');\n});\n","import acid from '../namespace/index';\nimport { assign } from '../internal/object';\nimport { eventAdd } from './event';\nimport { isDocumentReady } from './ready';\nexport const saveDimensions = () => {\n  assign(acid.appState, {\n    bodyHeight: document.body.offsetHeight,\n    bodyWidth: document.body.offsetWidth,\n    windowHeight: window.innerHeight,\n    windowWidth: window.innerWidth,\n  });\n};\nexport const updateDimensions = () => {\n  requestAnimationFrame(saveDimensions);\n};\nisDocumentReady(updateDimensions);\neventAdd(window, 'load', updateDimensions, true);\neventAdd(window, 'resize', updateDimensions, true);\nassign(acid, {\n  saveDimensions,\n  updateDimensions\n});\n","import acid from '../namespace/index';\nimport { assign } from '../internal/object';\nimport { isFunction } from '../internal/is';\nexport const ifInvoke = (method, ...args) => {\n  if (isFunction(method)) {\n    return method(...args);\n  }\n};\nassign(acid, {\n  ifInvoke\n});\n","import acid from '../namespace/index';\nimport { assign } from '../internal/object';\nimport { clear } from '../array/clear';\nimport { eachArray } from '../array/each';\nimport { ifInvoke } from '../function/ifInvoke';\nlet batchCancelFrame;\nconst batchChanges = [];\nconst batchLoop = () => {\n  eachArray(batchChanges, ifInvoke);\n  clear(batchChanges);\n  batchCancelFrame = false;\n};\nexport const batch = (...items) => {\n  batchChanges.push(...items);\n  if (!batchCancelFrame) {\n    batchCancelFrame = requestAnimationFrame(batchLoop);\n  }\n};\nassign(acid, {\n  batch\n});\n","import acid from '../namespace/index';\nimport { assign } from '../internal/object';\nconst protocol = location.protocol;\nconst protocolSocket = (protocol === 'http:') ? 'ws' : 'wss';\nconst hostname = location.hostname;\nexport const info = {\n  hardware: {\n    cores: navigator.hardwareConcurrency\n  },\n  host: {\n    name: hostname,\n    protocol,\n    protocolSocket,\n  }\n};\nassign(acid, {\n  info\n});\n","import acid from '../namespace/index';\nimport { assign } from '../internal/object';\nconst jsonNative = JSON;\n/**\n   * Parses JSON string.\n   *\n   * @function jsonParse\n   * @type {Function}\n   * @param {string} string - String to be parsed.\n   * @returns {Object} Returns the parsed object.\n   *\n   * @example\n   * jsonParse('{}');\n   * // => {}\n */\nexport const jsonParse = jsonNative.jsonParse;\n/**\n   * Stringify an object into a JSON string.\n   *\n   * @function stringify\n   * @type {Function}\n   * @param {Object} object - Object to Stringify.\n   * @returns {string} Returns the object as a valid JSON string.\n   *\n   * @example\n   * stringify({});\n   * // => '{}'\n */\nexport const stringify = jsonNative.stringify;\nassign(acid, {\n  jsonParse,\n  stringify\n});\n","import acid from '../namespace/index';\nimport { assign } from '../internal/object';\nimport { isString } from '../internal/is';\nimport { stringify } from '../utility/json';\nconst generateTheme = (color, bg) => {\n  return `color:${color};background:${bg};`;\n};\nconst themes = {\n  alert: generateTheme('#fff', '#f44336'),\n  important: generateTheme('#fff', '#E91E63'),\n  notify: generateTheme('#fff', '#651FFF'),\n  warning: generateTheme('#000', '#FFEA00'),\n};\nconst cnsl = (dataArg, themeName) => {\n  const data = isString(dataArg) ? dataArg : stringify(dataArg);\n  console.trace(`%c${data}`, `${themes[themeName]}font-size:13px;padding:2px 5px;border-radius:2px;`);\n};\nconst addConsoleTheme = (themeName, color, bg) => {\n  themes[themeName] = generateTheme(color, bg);\n};\nassign(acid, {\n  addConsoleTheme,\n  cnsl,\n});\n","import acid from '../namespace/index';\nimport { eachArray } from '../array/each';\nimport { isSameObjectGenerator, objectStringGenerate } from '../internal/is';\neachArray(['HTMLCollection', 'NodeList'], (item) => {\n  acid[`is${item}`] = isSameObjectGenerator(objectStringGenerate(item));\n});\n","import acid from '../namespace/index';\nimport { assign } from '../internal/object';\nexport const sortNewest = (arrayArg, key, pureMode) => {\n  const array = (pureMode) ? arrayArg : [...arrayArg];\n  return array.sort((previous, next) => {\n    if (!next[key]) {\n      return -1;\n    } else if (!previous[key]) {\n      return 1;\n    } else if (previous[key] < next[key]) {\n      return 1;\n    } else if (previous[key] > next[key]) {\n      return -1;\n    }\n    return 0;\n  });\n};\nexport const getNewest = (array, key) => {\n  return sortNewest(array, key)[0];\n};\nassign(acid, {\n  getNewest,\n  sortNewest,\n});\n","import acid from '../namespace/index';\nimport { assign } from '../internal/object';\nexport const sortOldest = (arrayArg, key, pureMode) => {\n  const array = (pureMode) ? arrayArg : [...arrayArg];\n  return array.sort((previous, next) => {\n    if (!next[key]) {\n      return -1;\n    } else if (!previous[key]) {\n      return 1;\n    } else if (previous[key] < next[key]) {\n      return 1;\n    } else if (previous[key] > next[key]) {\n      return -1;\n    }\n    return 0;\n  });\n};\nexport const getOldest = (array, key) => {\n  return sortOldest(array, key)[0];\n};\nassign(acid, {\n  getOldest,\n  sortOldest,\n});\n","import acid from '../namespace/index';\nimport { assign } from '../internal/object';\n// Creates a function that accepts up to n arguments ignoring any additional arguments. The 2nd argument will be binded if none the initial new function will be.\nexport const ary = (funct, amount) => {\n  return (...args) => {\n    return funct(...args.splice(0, amount));\n  };\n};\nassign(acid, {\n  ary\n});\n","import acid from '../namespace/index';\nimport { assign } from '../internal/object';\nimport { eachArray } from '../array/each';\nimport { clear } from '../array/clear';\nexport const curry = (funts) => {\n  const args = [];\n  const curried = (...curryArgs) => {\n    eachArray(curryArgs, (item) => {\n      args.push(item);\n    });\n    return curried;\n  };\n  curried.result = () => {\n    const results = funts(...args);\n    clear(args);\n    return results;\n  };\n  return curried;\n};\nexport const curryRight = (funts) => {\n  const args = [];\n  const curried = (...curryArgs) => {\n    eachArray(curryArgs, (item) => {\n      args.unshift(item);\n    });\n    return curried;\n  };\n  curried.result = () => {\n    const results = funts(...args);\n    clear(args);\n    return results;\n  };\n  return curried;\n};\nassign(acid, {\n  curry,\n  curryRight\n});\n","import acid from '../namespace/index';\nimport { assign } from '../internal/object';\n// Creates a function that is restricted to execute func once. Repeat calls to the function will return the value of the first call. The func is executed with the this binding of the created function.\nexport const once = (fn) => {\n  let value;\n  const onlyOnce = (...args) => {\n    if (!value) {\n      value = fn(...args);\n    }\n    return value;\n  };\n  return onlyOnce;\n};\n// Creates a function that executes func, with the this binding and arguments of the created function, only after being called n times.\nconst afterFn = (amountArg, fn) => {\n  let amount = amountArg;\n  const onlyAfter = (...args) => {\n    amount--;\n    if (amount < 0) {\n      return fn(...args);\n    }\n  };\n  return onlyAfter;\n};\n// Creates a function that executes func, with the this binding and arguments of the created function, only before being called n times.\nconst beforeFn = (amountArg, fn) => {\n  let amount = amountArg;\n  const onlyBefore = (...args) => {\n    amount--;\n    if (amount > 0) {\n      return fn(...args);\n    }\n  };\n  return onlyBefore;\n};\n// Creates a function that executes func, with the this binding and arguments of the created function, only after or equal to being called n times.\nexport const onAfter = (amount, fn) => {\n  return afterFn(amount - 1, fn);\n};\n// Creates a function that executes func, with the this binding and arguments of the created function, only before or equal to being called n times.\nexport const onBefore = (amount, fn) => {\n  return beforeFn(amount + 1, fn);\n};\nassign(acid, {\n  onAfter,\n  onBefore,\n  once\n});\n","import acid from '../namespace/index';\nimport { assign } from '../internal/object';\nexport const stubObject = () => {\n  return {};\n};\nexport const stubArray = () => {\n  return [];\n};\nexport const stubString = () => {\n  return '';\n};\nexport const stubFalse = () => {\n  return false;\n};\nexport const stubTrue = () => {\n  return true;\n};\nexport const noop = () => {\n  return undefined;\n};\nassign(acid, {\n  stubObject,\n  stubArray,\n  stubString,\n  stubTrue,\n  stubFalse,\n  noop\n});\n","import acid from '../namespace/index';\nimport { assign } from '../internal/object';\nimport { compactMapArray, eachArray, filterArray, mapArray } from '../array/each';\nimport { compactMapObject, eachObject, filterObject, mapObject } from '../object/each';\nimport { hasValue, isArray, isFunction, isPlainObject } from '../internal/is';\nconst forEachWrap = (object, callback) => {\n  return object.forEach(callback);\n};\nconst generateCheckLoops = (arrayLoop, objectLoop) => {\n  return (callingObject, iteratee, results) => {\n    let returned;\n    if (!hasValue(callingObject)) {\n      return;\n    } else if (isArray(callingObject)) {\n      returned = arrayLoop;\n    } else if (isPlainObject(callingObject) || isFunction(callingObject)) {\n      returned = objectLoop;\n    } else if (callingObject.forEach) {\n      returned = forEachWrap;\n    } else {\n      returned = objectLoop;\n    }\n    return returned(callingObject, iteratee, results);\n  };\n};\n/**\n  * Iterates through the given object.\n  *\n  * @function each\n  * @type {Function}\n  * @param {Array|Object|Function} callingObject - Object that will be looped through.\n  * @param {Function} iteratee - Transformation function which is passed item, key, the newly created map object and arguments unique to mapArray or mapObject depending on the object type.\n  * @returns {Array|Object|Function} The originally given object.\n  *\n  * @example\n  * each([1, 2, 3], (item) => {\n  *   console.log(item);\n  * });\n  * // => [1, 2, 3]\n  * each({a: 1, b: 2, c: 3}, (item) => {\n  *   console.log(item);\n  * });\n  * // => {a: 1, b: 2, c: 3}\n*/\nexport const each = generateCheckLoops(eachArray, eachObject);\n/**\n  * Iterates through the calling object and creates a new object of the same calling object's type with all elements that pass the test implemented by the iteratee.\n  *\n  * @function filter\n  * @type {Function}\n  * @param {Array|Object|Function} callingObject - Object that will be looped through.\n  * @param {Function} iteratee - Transformation function which is passed item, key, the newly created map object and arguments unique to mapArray or mapObject depending on the object type.\n  * @param {Object|Function} [results = {}] - Object that will be used to assign results.\n  * @returns {Array|Object|Function} - A new object of the same calling object's type.\n  *\n  * @example\n  * filter([false, true, true], (item) => {\n  *   return item;\n  * });\n  * // => [true, true]\n  * filter({a: false, b: true, c: true}, (item) => {\n  *   return true;\n  * });\n  * // => {b: true, c: true}\n*/\nexport const filter = generateCheckLoops(filterArray, filterObject);\n/**\n  * Iterates through the calling object and creates a new object based on the calling object's type with the results of the iteratee on every element in the calling object.\n  *\n  * @function map\n  * @category Utility\n  * @type {Function}\n  * @param {Array|Object|Function} callingObject - Object that will be looped through.\n  * @param {Function} iteratee - Transformation function which is passed item, key, the newly created map object and arguments unique to mapArray or mapObject depending on the object type.\n  * @param {Object|Function} [results = {}] - Object that will be used to assign results.\n  * @returns {Array|Object|Function} A new object of the same calling object's type.\n  *\n  * @example\n  * map([1, 2, 3], (item) => {\n  *   return item * 2;\n  * });\n  * // => [2, 4, 6]\n  * map({a: 1, b: 2, c: 3}, (item) => {\n  *   return item * 2;\n  * });\n  * // => {a: 2, b: 4, c: 6}\n*/\nexport const map = generateCheckLoops(mapArray, mapObject);\n/**\n  * Iterates through the calling object and creates a new object based on the calling object's type with the results, (excludes results which are null or undefined), of the iteratee on every element in the calling object.\n  *\n  * @function compactMap\n  * @type {Function}\n  * @param {Array|Object|Function} callingObject - Object that will be looped through.\n  * @param {Function} iteratee - Transformation function which is passed item, key, the newly created map object and arguments unique to mapArray or mapObject depending on the object type.\n  * @param {Object|Function} [results = {}] - Object that will be used to assign results.\n  * @returns {Array|Object|Function} A new object of the same calling object's type.\n  *\n  * @example\n  * compactMap([0, 2, 3], (item) => {\n  *   return item * 2;\n  * });\n  * // => [4, 6]\n  * compactMap({a: 0, b: 2, c: 3}, (item) => {\n  *   return item * 2;\n  * });\n  * // => {b: 4, c: 6}\n*/\nexport const compactMap = generateCheckLoops(compactMapArray, compactMapObject);\nassign(acid, {\n  compactMap,\n  each,\n  filter,\n  map\n});\n","import acid from '../namespace/index';\nimport { assign } from '../internal/object';\nimport { isFunction } from '../internal/is';\nimport { map } from '../utility/each';\nexport const bindAll = (bindThese, withThis) => {\n  return map(bindThese, (item) => {\n    return isFunction(item) ? item.bind(withThis) : item;\n  });\n};\nassign(acid, {\n  bindAll\n});\n","import acid from '../namespace/index';\nimport { assign } from '../internal/object';\n// Creates a function that negates the result of the predicate func. The func predicate is invoked with the this binding and arguments of the created function.\nexport const negate = (func) => {\n  return (...args) => {\n    return !func(...args);\n  };\n};\nassign(acid, {\n  negate\n});\n","import acid from '../namespace/index';\nimport { assign } from '../internal/object';\nexport const overEvery = (array) => {\n  return (...args) => {\n    let result;\n    array.find(array, (item) => {\n      result = Boolean(item(...args));\n      return result;\n    });\n    return result;\n  };\n};\nexport const over = (array) => {\n  return (...args) => {\n    return array.map((item) => {\n      return item(...args);\n    });\n  };\n};\nassign(acid, {\n  over,\n  overEvery,\n});\n","import acid from '../namespace/index';\nimport { assign } from '../internal/object';\nimport { times } from '../array/each';\nexport const timer = (fn, time) => {\n  return setTimeout(fn, time);\n};\nexport const interval = (fn, time) => {\n  return setInterval(fn, time);\n};\nconst generateClear = (method, clearMethod) => {\n  return (max) => {\n    times(0, method(() => {}, max || 1000), (index) => {\n      clearMethod(index);\n    });\n  };\n};\nexport const clearTimers = generateClear(timer, clearTimeout);\nexport const clearIntervals = generateClear(interval, clearInterval);\nexport const debounce = (original, time) => {\n  let timeout = false;\n  const fn = (...args) => {\n    if (timeout !== false) {\n      clearTimeout(timeout);\n    }\n    timeout = timer(() => {\n      original(...args);\n      timeout = false;\n    }, time);\n  };\n  fn.clear = () => {\n    if (timeout) {\n      clearTimeout(timeout);\n      timeout = false;\n    }\n  };\n  return fn;\n};\nexport const throttle = (func, time) => {\n  let timeout = false;\n  let shouldThrottle;\n  const fn = (...args) => {\n    if (timeout) {\n      shouldThrottle = true;\n      return;\n    }\n    func(...args);\n    timeout = timer(() => {\n      if (shouldThrottle) {\n        func(...args);\n      }\n      timeout = false;\n    }, time);\n  };\n  fn.clear = () => {\n    clearTimeout(timeout);\n    timeout = false;\n  };\n  return fn;\n};\nassign(acid, {\n  debounce,\n  interval,\n  throttle,\n  timer,\n});\n","import acid from '../namespace/index';\nimport { assign } from '../internal/object';\nimport { each } from '../utility/each';\nconst addLink = (link, addToChain) => {\n  each(addToChain, (item, key) => {\n    link.methods[key] = (...args) => {\n      args.unshift(link.value);\n      item(...args);\n      return link.methods;\n    };\n  });\n  return link;\n};\nexport const chain = (methods) => {\n  const link = (value) => {\n    link.value = value;\n    return link.methods;\n  };\n  assign(link, {\n    methods: {},\n    link(addToChain) {\n      return addLink(link, addToChain);\n    },\n    done() {\n      const value = link.value;\n      link.value = null;\n      return value;\n    }\n  });\n  link.link(methods);\n  return link;\n};\nassign(acid, {\n  chain\n});\n","import acid from '../namespace/index';\nimport { assign } from '../internal/object';\nimport { each } from '../utility/each';\nimport { eachAsync } from '../array/eachAsync';\nexport const inSync = (fns, arg) => {\n  return each(fns, (item) => {\n    item(arg);\n  });\n};\nexport const inAsync = async (fns, arg) => {\n  await eachAsync(fns, async (item) => {\n    await item(arg);\n  });\n};\nassign(acid, {\n  inAsync,\n  inSync,\n});\n","import acid from '../namespace/index';\nimport { assign } from '../internal/object';\nexport const nthArg = (numArg) => {\n  let num = numArg;\n  return (...args) => {\n    if (num < 0) {\n      num = args.length - (num * -1);\n    }\n    return args[num];\n  };\n};\nassign(acid, {\n  nthArg\n});\n","import acid from '../namespace/index';\nimport { assign } from '../internal/object';\n// Creates a function that invokes func with arguments arranged according to the specified indexes where the argument value at the first index is provided as the first argument, the argument value at the second index is provided as the second argument, and so on.\nexport const reArg = (funct, list) => {\n  return (...args) => {\n    return funct(...list.map((item) => {\n      return args[item];\n    }));\n  };\n};\n/*\nvar rearg=(function(a, b, c) {\n  return [a, b, c];\n},[1,2,0]);\n\nrearg(1,2,3);\n-> [2, 3, 1]\n*/\nassign(acid, {\n  reArg\n});\n","import acid from '../namespace/index';\nimport { assign } from '../internal/object';\nexport const wrap = (...args) => {\n  const list = [];\n  const wrapped = (...wrappedArgs) => {\n    return list.map((item) => {\n      return item(...wrappedArgs);\n    });\n  };\n  assign(wrapped, {\n    list,\n    add(...addTheseArg) {\n      list.push(...addTheseArg);\n    },\n  });\n  wrapped.add(args);\n  return wrapped;\n};\nexport const wrapBefore = (...args) => {\n  const list = [];\n  const wrapped = (...wrappedArgs) => {\n    return list.map((item) => {\n      return item(...wrappedArgs);\n    });\n  };\n  assign(wrapped, {\n    list,\n    add(...addThese) {\n      list.unshift(...addThese.reverse());\n    },\n  });\n  wrapped.add(args);\n  return wrapped;\n};\nassign(acid, {\n  wrap,\n  wrapBefore\n});\n","import acid from '../namespace/index';\nimport { assign } from '../internal/object';\n/**\n  * Strictly checks if a number is zero.\n  *\n  * @function isZero\n  * @type {Function}\n  * @param {number} item - Number to be checked.\n  * @returns {boolean} True or False.\n  *\n  * @example\n  * isZero(0);\n  * // => true\n  *\n  * isZero(1);\n  * // => False\n*/\nexport const isZero = (item) => {\n  return item === 0;\n};\n/**\n  * Strictly checks if a number equal to another number.\n  *\n  * @function isNumberEqual\n  * @type {Function}\n  * @param {number} item - Number to be checked against num.\n  * @param {number} num - Number to be checked against item.\n  * @returns {boolean} True or False.\n  *\n  * @example\n  * isNumberEqual(0, 0);\n  * // => true\n  *\n  * isNumberEqual(0, 1);\n  * // => False\n*/\nexport const isNumberEqual = (item, num) => {\n  return item === num;\n};\n/**\n  * Checks if a number is within a range.\n  *\n  * @function isNumberInRange\n  * @type {Function}\n  * @param {number} num - Number to be checked.\n  * @param {number} [start = 0] - Beginning of range.\n  * @param {number} [end] - End of range.\n  * @returns {boolean} True or False.\n  *\n  * @example\n  * isNumberInRange(1, 0, 2);\n  * // => True\n  *\n  * isNumberInRange(1, -1, 0);\n  * // => False\n*/\nexport const isNumberInRange = (num, start = 0, end = start) => {\n  return num > start && num < end;\n};\nassign(acid, {\n  isNumberEqual,\n  isNumberInRange,\n  isZero\n});\n","import acid from '../namespace/index';\nimport { eachWhile } from '../array/each';\nimport { assign, keys } from '../internal/object';\n/**\n  * Checks to see if an object has all of the given property names.\n  *\n  * @function compactKeys\n  * @type {Function}\n  * @param {Object} object - Object from which keys are extracted.\n  * @param {Array} properties - Array of object keys.\n  * @returns {boolean} - Returns true or false.\n  *\n  * @example\n  * hasKeys({Lucy: 'Ringo', John: 'Malkovich', Thor: 'Bobo'}, ['Lucy','Thor']);\n  * //=> true\n  *\n  * hasKeys({Lucy: 'Ringo', John: 'Malkovich', Thor: 'Bobo'}, ['Lucy','Tom']);\n  * //=> false\n*/\nexport const hasKeys = (object, properties) => {\n  let flag = false;\n  const objectKeys = keys(object);\n  eachWhile(properties, (item) => {\n    flag = objectKeys.include(item);\n    return flag;\n  });\n  return flag;\n};\n/**\n  * Checks to see if an object has any of the given property names.\n  *\n  * @function hasAnyKeys\n  * @type {Function}\n  * @param {Object} object - Object from which keys are extracted.\n  * @param {Array} properties - Array of object keys.\n  * @returns {boolean} - Returns true or false.\n  *\n  * @example\n  * hasAnyKeys({Lucy: 'Ringo', John: 'Malkovich', Thor: 'Bobo'}, ['Lucy','John']);\n  * //=> true\n  *\n  * hasAnyKeys({Lucy: 'Ringo', John: 'Malkovich', Thor: 'Bobo'}, ['Lucy','Tom']);\n  * //=> true\n*/\nexport const hasAnyKeys = (object, properties) => {\n  const objectKeys = keys(object);\n  const flag = properties.find((item) => {\n    return objectKeys.include(item);\n  });\n  return flag;\n};\nassign(acid, {\n  hasAnyKeys,\n  hasKeys,\n});\n","import acid from '../namespace/index';\nimport { arraySortToObject } from '../array/sortToObject';\nimport { assign } from '../internal/object';\nconst pick = (array, originalObject, newObject) => {\n  return arraySortToObject((item, key, object) => {\n    object[item] = originalObject[item];\n  }, array, newObject);\n};\nassign(acid, {\n  pick\n});\n","import acid from '../namespace/index';\nimport { assign } from '../internal/object';\nimport { eachObject } from '../object/each';\nimport { hasValue } from '../internal/is';\n/**\n  * Extracts all key values from an object.\n  *\n  * @function compactKeys\n  * @type {Function}\n  * @param {Object} object - Object from which keys are extracted.\n  * @returns {Array} - Returns an array of key values.\n  *\n  * @example\n  * compactKeys({Lucy: 'Ringo', John: 'Malkovich', Thor: undefined, other: false, that: null});\n  * //=> ['Lucy', 'John', 'other']\n  *\n*/\nexport const compactKeys = (object) => {\n  const keys = [];\n  eachObject(object, (item, key) => {\n    if (hasValue(item)) {\n      keys.push(key);\n    }\n  });\n  return keys;\n};\nassign(acid, {\n  compactKeys\n});\n","import acid from '../namespace/index';\nimport { eachWhile } from '../array/each';\nimport { isMatchArray } from '../array/isMatch';\nimport { assign, keys } from '../internal/object';\n/**\n   * Performs a shallow strict comparison between two objects.\n   *\n   * @function isMatchObject\n   * @type {Function}\n   * @param {Object} source - Source object.\n   * @param {Object} compareObject - Object to compare to source.\n   * @returns {boolean} Returns the true or false.\n   *\n   * @example\n   * isMatchObject({a: [1,2,3]}, {a: [1,2,3]});\n   * // => true\n */\nexport const isMatchObject = (source, compareObject) => {\n  const sourceProperties = keys(source);\n  if (isMatchArray(sourceProperties, keys(compareObject))) {\n    return eachWhile(sourceProperties, (key) => {\n      return source[key] === compareObject[key];\n    });\n  }\n  return false;\n};\nassign(acid, {\n  isMatchObject,\n});\n","import acid from '../namespace/index';\nimport { arraySortToObject } from '../array/sortToObject';\nimport { assign } from '../internal/object';\nimport { eachObject } from './each';\nexport const zipObject = (keys, values) => {\n  return arraySortToObject((item, index, object) => {\n    object[item] = values[index];\n  }, keys);\n};\nexport const unZipObject = (object) => {\n  const keys = [];\n  const values = [];\n  eachObject(object, (item, key) => {\n    keys.push(key);\n    values.push(item);\n  });\n  return [keys, values];\n};\nassign(acid, {\n  unZipObject,\n  zipObject,\n});\n","import acid from '../namespace/index';\nimport { assign } from '../internal/object';\nimport { eachObject } from './each';\nexport const invert = (thisObject, invertedObject = {}) => {\n  eachObject(thisObject, (item, key) => {\n    invertedObject[item] = key;\n  });\n  return invertedObject;\n};\nassign(acid, {\n  invert,\n});\n","import acid from '../namespace/index';\nimport { assign } from '../internal/object';\nimport { filterObject } from './each';\nexport const omit = (originalObject, array) => {\n  return filterObject(originalObject, (item, key) => {\n    return !array.includes(key);\n  });\n};\nassign(acid, {\n  omit\n});\n","import acid from '../namespace/index';\nimport { assign } from '../internal/object';\nconst normalizeCase = /[-_]/g;\nconst spaceFirstLetter = / (.)/g;\n/**\n  * Converts a string and converts it entirely into uppercase.\n  *\n  * @function upperCase\n  * @type {Function}\n  * @param {string} string - String to be converted into upper case.\n  * @returns {string} - Converted string in upper case.\n  *\n  * @example\n  * upperCase('upper case');\n  * // => UPPER CASE\n*/\nexport const upperCase = (string) => {\n  return string.replace(normalizeCase, ' ')\n    .trim()\n    .toUpperCase();\n};\n/**\n  * Converts a string into Camel case format.\n  *\n  * @function camelCase\n  * @type {Function}\n  * @param {string} string - String to be converted into Camel case.\n  * @returns {string} - Converted string in Camel case.\n  *\n  * @example\n  * camelCase('camel case');\n  * // => camelCase\n*/\nexport const camelCase = (string) => {\n  return string.toLowerCase()\n    .replace(spaceFirstLetter, (match) => {\n      return match.toUpperCase();\n    });\n};\n/**\n  * Converts a string into Kebab case format.\n  *\n  * @function kebabCase\n  * @type {Function}\n  * @param {string} string - String to be converted into Kebab case.\n  * @returns {string} - Converted string in Kebab case.\n  *\n  * @example\n  * kebabCase('kebab case');\n  * // => kebab-case\n*/\nexport const kebabCase = (string) => {\n  return string.replace(normalizeCase, ' ')\n    .trim()\n    .toLowerCase()\n    .replace(spaceFirstLetter, '-$1');\n};\n/**\n  * Converts a string into snake case format.\n  *\n  * @function snakeCase\n  * @type {Function}\n  * @param {string} string - String to be converted into snake case.\n  * @returns {string} - Converted string in Snake case.\n  *\n  * @example\n  * snakeCase('snake case');\n  * // => snake_case\n*/\nexport const snakeCase = (string) => {\n  return string.replace(normalizeCase, ' ')\n    .trim()\n    .toLowerCase()\n    .replace(spaceFirstLetter, '_$1');\n};\nassign(acid, {\n  camelCase,\n  kebabCase,\n  snakeCase,\n  upperCase,\n});\n","import acid from '../namespace/index';\nimport { assign } from '../internal/object';\n/**\n  * Replaces all occurrences of strings in an array with a value.\n  *\n  * @function replaceList\n  * @type {Function}\n  * @param {string} string - String to be replaced.\n  * @param {Array} array - Strings to replace.\n  * @param {string} value - The match replacement.\n  * @returns {string} - The string with the replacement.\n  *\n  * @example\n  * replaceList('Her name was @user.', ['@user'], 'Lucy');\n  * // => Her name was Lucy.\n*/\nexport const replaceList = (string, array, value) => {\n  return string.replace(new RegExp(`\\\\b${array.join('|')}\\\\b`, 'gi'), value);\n};\nassign(acid, {\n  replaceList\n});\n","import acid from '../namespace/index';\nimport { assign } from '../internal/object';\nconst rawURLDecodeRegex = /%(?![\\da-f]{2})/gi;\nconst andRegex = /&/g;\nconst lessThanRegex = /</g;\nconst moreThanRegex = />/g;\nconst doubleQuoteRegex = /\"/g;\n/**\n  * Raw URL decoder.\n  *\n  * @function rawURLDecode\n  * @type {Function}\n  * @param {string} string - String to be replaced.\n  * @returns {string} - Converted string into the decoded URI Component .\n  *\n  * @example\n  * rawURLDecode('Lucy%20saw%20diamonds%20in%20the%20sky.');\n  * // => Lucy saw diamonds in the sky.\n*/\nexport const rawURLDecode = (string) => {\n  return decodeURIComponent(string.replace(rawURLDecodeRegex, () => {\n    return '%25';\n  }));\n};\n/**\n  * Replaced sensitive characters with their matching html entity.\n  *\n  * @function htmlEntities\n  * @type {Function}\n  * @param {string} string - String to be replaced.\n  * @returns {string} Replaced string.\n  *\n  * @example\n  * htmlEntities(`<script>console.log('Lucy & diamonds.')</script>`);\n  * // => &lt;script&gt;console.log('Lucy &amp; diamonds.')&lt;/script&gt;\n*/\nexport const htmlEntities = (string) => {\n  return string.replace(andRegex, '&amp;')\n    .replace(lessThanRegex, '&lt;')\n    .replace(moreThanRegex, '&gt;')\n    .replace(doubleQuoteRegex, '&quot;');\n};\n/**\n  * Executes rawURLDecode followd by htmlEntities methods on a string.\n  *\n  * @function sanitize\n  * @type {Function}\n  * @param {string} string - String to be replaced.\n  * @returns {string} Replaced string.\n  *\n  * @example\n  * sanitize(`<script>console.log('Lucy%20&%20diamonds.')</script>`);\n  * // => &lt;script&gt;console.log('Lucy &amp; diamonds.')&lt;/script&gt;\n*/\nexport const sanitize = (string) => {\n  return htmlEntities(rawURLDecode(string));\n};\nassign(acid, {\n  htmlEntities,\n  rawURLDecode,\n  sanitize\n});\n","import acid from '../namespace/index';\nimport { assign } from '../internal/object';\nconst tokenizeRegEx = /\\S+/g;\nconst wordsRegEx = /\\w+/g;\n/**\n  * Break string by non-white space characters matches.\n  *\n  * @function tokenize\n  * @type {Function}\n  * @param {string} string - String to be broken up.\n  * @returns {Array} - Array of words without white space characters.\n  *\n  * @example\n  * tokenize('I am Lucy!');\n  * // => [\"I\", \"am\", \"Lucy!\"]\n*/\nexport const tokenize = (string) => {\n  return string.match(tokenizeRegEx) || [];\n};\n/**\n  * Break string into word matches.\n  *\n  * @function words\n  * @type {Function}\n  * @param {string} string - String to be broken up.\n  * @returns {Array} - Array of words with word characters only.\n  *\n  * @example\n  * words('I am Lucy!');\n  * // => [\"I\", \"am\", \"Lucy\"]\n*/\nexport const words = (string) => {\n  return string.match(wordsRegEx) || [];\n};\nassign(acid, {\n  tokenize,\n  words\n});\n","import acid from '../namespace/index';\nimport { assign } from '../internal/object';\nconst truncateDown = (string, maxLength, stringLength) => {\n  const breakAll = string.split('');\n  const breakAllLength = breakAll.length;\n  let item;\n  let index = stringLength - maxLength;\n  for (; index < breakAllLength && index >= 0; index--) {\n    item = breakAll[index];\n    if (item === ' ') {\n      break;\n    }\n  }\n  return string.slice(0, index).trim();\n};\nconst truncateUp = (string, maxLength, stringLength) => {\n  const breakAll = string.split('');\n  const breakAllLength = breakAll.length;\n  let item;\n  let index = maxLength;\n  for (; index < breakAllLength && index > 0; index++) {\n    item = breakAll[index];\n    if (item === ' ') {\n      break;\n    }\n  }\n  return string.substr(index, stringLength).trim();\n};\n/**\n  * Truncates the string, accounting for word placement and character count.\n  *\n  * @function truncate\n  * @type {Function}\n  * @param {string} string - String to be truncated.\n  * @param {number} maxLength - The desired max length of the string.\n  * @returns {string} - An upper case letter.\n  *\n  * @example\n  * truncate('Where is Lucy?', 2);\n  * // => Where\n*/\nexport const truncate = (string, maxLength) => {\n  const stringLength = string.length;\n  return (stringLength > maxLength) ? truncateDown(string, maxLength, stringLength) : string;\n};\n/**\n  * Truncates the string, accounting for word placement and character count from the right.\n  *\n  * @function truncateRight\n  * @type {Function}\n  * @param {string} string - String to be truncated.\n  * @param {number} maxLength - The desired max length of the string.\n  * @returns {string} - An upper case letter.\n  *\n  * @example\n  * truncateRight('Where is Lucy?', 6);\n  * // => Lucy?\n*/\nexport const truncateRight = (string, maxLength) => {\n  const stringLength = string.length;\n  return (stringLength > maxLength) ? truncateUp(string, maxLength, stringLength) : string;\n};\nassign(acid, {\n  truncate,\n  truncateRight,\n});\n","import acid from '../namespace/index';\nimport { assign } from '../internal/object';\nimport { restString } from './range';\nconst spaceFirstLetter = / (.)/g;\n/**\n  * Returns the first letter capitalized.\n  *\n  * @function upperFirstLetter\n  * @type {Function}\n  * @param {string} string - String to extract first letter from.\n  * @returns {string} - An upper case letter.\n  *\n  * @example\n  * upperFirstLetter('upper');\n  * // => U\n*/\nexport const upperFirstLetter = (string) => {\n  return string[0].toUpperCase();\n};\n/**\n  * Capitalizes the first letter.\n  *\n  * @function upperFirst\n  * @type {Function}\n  * @param {string} string - String to be mutated.\n  * @returns {string} - String with first letter capitalized.\n  *\n  * @example\n  * upperFirstLetter('upper');\n  * // => Upper\n*/\nexport const upperFirst = (string) => {\n  return upperFirstLetter(string) + restString(string);\n};\n/**\n  * Capitalize all first letters.\n  *\n  * @function upperFirstAll\n  * @type {Function}\n  * @param {string} string - String to be mutated.\n  * @returns {string} - String with all first letters capitalized.\n  *\n  * @example\n  * upperFirstAll('Lucy is next up.');\n  * // => Lucy Is Next Up.\n*/\nexport const upperFirstAll = (string) => {\n  return string.replace(spaceFirstLetter, (match) => {\n    return match.toUpperCase();\n  });\n};\n/**\n  * Capitalize first letter and lower case the rest.\n  *\n  * @function upperFirstOnly\n  * @type {Function}\n  * @param {string} string - String to be mutated.\n  * @returns {string} - String with first letter capitalized.\n  *\n  * @example\n  * upperFirstOnly('LYSERGIC ACID DIETHYLAMIDE');\n  * // => Lysergic acid diethylamide\n*/\nexport const upperFirstOnly = (string) => {\n  return upperFirstLetter(string) + restString(string).toLowerCase();\n};\n/**\n  * Capitalize all first letters and lower case the rest.\n  *\n  * @function upperFirstOnlyAll\n  * @type {Function}\n  * @param {string} string - String to be mutated.\n  * @returns {string} - String with all first letters capitalized.\n  *\n  * @example\n  * upperFirstOnlyAll('LYSERGIC ACID DIETHYLAMIDE');\n  * // => Lysergic Acid Diethylamide\n*/\nexport const upperFirstOnlyAll = (string) => {\n  return string.toLowerCase()\n    .replace(spaceFirstLetter, (match) => {\n      return match.toUpperCase();\n    });\n};\nassign(acid, {\n  upperFirst,\n  upperFirstAll,\n  upperFirstOnly,\n  upperFirstOnlyAll,\n});\n","import acid from '../namespace/index';\nimport { assign } from '../internal/object';\nimport { each } from './each';\nimport { isArray, isPlainObject } from '../internal/is';\n/**\n  * Creates new object with deeply assigned values from another object/array.\n  *\n  * @function assignDeep\n  * @type {Function}\n  * @param {Object} object - Object to be assigned new properties.\n  * @param {Object} otherObject - Object from which properties are extracted.\n  * @param {boolean} [mergeArrays = true] - Array from which items are assigned to the new object.\n  * @returns {Object} - Returns object with the newly assigned properties.\n  *\n  * @example\n  * assignDeep({a:1}, {b:2})\n  * //=> {a:1, b:2}\n  *\n*/\nexport const assignDeep = (object, otherObject, mergeArrays = true) => {\n  each(otherObject, (item, key) => {\n    if (isPlainObject(item) && isPlainObject(object[key])) {\n      assignDeep(object[key], item, mergeArrays);\n    } else if (mergeArrays && isArray(item) && isArray(object[key])) {\n      object[key].push(...item);\n    } else {\n      object[key] = item;\n    }\n  });\n  return object;\n};\nassign(acid, {\n  assignDeep\n});\n","import acid from '../namespace/index';\nimport { assign } from '../internal/object';\nconst functionPrototype = Function.prototype;\n/**\n  * Caches a prototype method.\n  *\n  * @function cacheNativeMethod\n  * @type {Function}\n  * @param {Function} method - Prototype method.\n  * @returns {Function} - Cached method.\n  *\n  * @example\n  * cacheNativeMethod(Array.prototype.push);\n  * // => function call() { [native code] }\n*/\nexport function cacheNativeMethod(method) {\n  return functionPrototype.call.bind(method);\n}\nassign(acid, {\n  cacheNativeMethod\n});\n","import acid from '../namespace/index';\nimport { assign } from '../internal/object';\nimport { hasValue } from '../internal/is';\n/**\n   * Checks if a property on an object has a value. If not, it will assign a value.\n   *\n   * @function ifNotEqual\n   * @type {Function}\n   * @param {Object} rootObject - The object to check.\n   * @param {string} property - The property name which is to be checked.\n   * @param {*} equalThis - The reassignment value for the property being checked.\n   * @returns {Object} - Returns the provided rootObject.\n   *\n   * @example\n   * ifNotEqual({}, 'a', 1);\n   * // => {a:1}\n */\nexport const ifNotEqual = (rootObject, property, equalThis) => {\n  if (property && !hasValue(rootObject[property])) {\n    rootObject[property] = equalThis;\n  }\n  return rootObject;\n};\nassign(acid, {\n  ifNotEqual,\n});\n","import acid from '../namespace/index';\nimport { eachWhile } from '../array/each';\nimport { isMatchArray } from '../array/isMatch';\nimport { assign, keys } from '../internal/object';\nimport { isArray, isPlainObject } from '../internal/is';\n/**\n   * Performs a deep comparison between two objects.\n   *\n   * @function isEqual\n   * @type {Function}\n   * @param {Object} source - Source object.\n   * @param {Object} compareObject - Object to compare to source.\n   * @returns {boolean} Returns the true or false.\n   *\n   * @example\n   * isEqual({a: [1,2,3]}, {a: [1,2,3]});\n   * // => true\n */\nexport const isEqual = (object, compareObject) => {\n  if (object === compareObject) {\n    return true;\n  } else if (object.toString() === compareObject.toString()) {\n    if (isPlainObject(object)) {\n      const sourceProperties = keys(object);\n      if (isMatchArray(sourceProperties, keys(compareObject))) {\n        return eachWhile(sourceProperties, (key) => {\n          return isEqual(object[key], compareObject[key]);\n        });\n      }\n    } else if (isArray(object)) {\n      if (object.length === compareObject.length) {\n        return eachWhile(object, (item, index) => {\n          return isEqual(item, compareObject[index]);\n        });\n      }\n    }\n  }\n  return false;\n};\nassign(acid, {\n  isEqual,\n});\n","import acid from '../namespace/index';\nimport { eachWhile } from '../array/each';\nimport { isEqual } from './isEqual';\nimport { assign, keys } from '../internal/object';\n/**\n  * Using a deep comparison it checks if properties of two objects using an array are equal.\n  *\n  * @function propertyMatch\n  * @type {Function}\n  * @property {Object} - takes an object.\n  * @property {Object} - takes an object.\n  * @property {Array} - takes in an array of properties.\n  *\n  * @example\n  * propertyMatch({\n  *   a: 1,\n  *   b: 2\n  * }, {\n  *   a: 1,\n  *   b: 2\n  * }, ['a', 'b']);\n  * //-> true\n*/\nexport const propertyMatch = (object, compareObject, properties = keys(object)) => {\n  let result = false;\n  eachWhile(properties, (property) => {\n    result = isEqual(object[property], compareObject[property]);\n    return result;\n  });\n  return result;\n};\nassign(acid, {\n  propertyMatch,\n});\n","import acid from '../namespace/index';\nimport { assign } from '../internal/object';\nconst regexToPath = /\\.|\\[/;\nconst regexCloseBracket = /]/g;\nconst emptyString = '';\n/**\n  * Breaks up string into object chain list.\n  *\n  * @function toPath\n  * @type {Function}\n  * @param {string} string - String to be broken up.\n  * @returns {Array} - Array used to go through object chain.\n  * \n  * @example\n  * toPath('post.like[2]');\n  * //=> ['post', 'like', '2']\n*/\nexport const toPath = (string) => {\n  return string.replace(regexCloseBracket, emptyString).split(regexToPath);\n};\nassign(acid, {\n  toPath,\n});\n","import acid from '../namespace/index';\nimport { assign } from '../internal/object';\nimport { hasValue } from '../internal/is';\nlet count = 0;\nconst uidFree = [];\nconst uidClosed = {};\n/**\n  * Creates a numerical unique ID and recycles old ones. UID numerically ascends however freed UIDs are later reused.\n  *\n  * @function uid\n  * @category utility\n  * @type {Function}\n  * @returns {number} - Returns a unique id.\n  *\n  * @example\n  * uid();\n  * //=> 0\n  *\n  * uid();\n  * //=> 1\n*/\nexport const uid = () => {\n  let result = uidFree.shift(uidFree);\n  if (!hasValue(result)) {\n    result = count;\n    uidClosed[result] = true;\n    count++;\n  }\n  return result;\n};\n/**\n  * Frees an UID so that it may be recycled for later use.\n  *\n  * @function free\n  * @memberof uid\n  * @type {Function}\n  * @param {number} id - Number to be freed.\n  * @returns {undefined} - Nothing is returned.\n  *\n  * @example\n  * uid();\n  * //=> 0\n  *\n  * uid();\n  * //=> 1\n  *\n  * uid.free(0);\n  * //=> undefined\n  *\n  * uid();\n  * //=> 0\n*/\nconst free = (id) => {\n  uidClosed[id] = null;\n  uidFree.push(id);\n};\nuid.free = free;\nassign(acid, {\n  uid,\n});\n","import acid from '../namespace/index';\nimport { assign } from '../internal/object';\nimport { eachWhile } from '../array/each';\nimport { hasValue } from '../internal/is';\nimport { toPath } from '../utility/toPath';\n/**\n  * Returns property on an object.\n  *\n  * @function get\n  * @type {Function}\n  * @param  {string} propertyString - String used to retrieve properties.\n  * @param {Object} objectChain - Object which has a property retrieved from it.\n  * @returns {Object} - Returns property from the given object.\n  *\n  * @example\n  * const api = {\n  *  post: {\n  *   like: ['a','b','c']\n  *  }\n  * }\n  * get('post.like[2]', api);\n  * //=> c\n  *\n*/\nexport const get = (propertyString, objectChain = acid) => {\n  let link = objectChain;\n  eachWhile(toPath(propertyString), (item) => {\n    link = link[item];\n    return hasValue(link);\n  });\n  return link;\n};\nassign(acid, {\n  get\n});\n","import acid from '../namespace/index';\nimport { assign } from '../internal/object';\nimport { get } from './get';\nimport { hasValue } from '../internal/is';\n/**\n  * Set & Get a model.\n  *\n  * @function model\n  * @type {Function}\n  * @param {string} modelName - Name of the model.\n  * @property {Object} - The model object.\n  * @returns {*} Returns the associated model.\n  *\n  * @example\n  * model('test', {a: 1});\n  * //=> {a: 1}\n  *\n  * model('test');\n  * //=> {a: 1}\n*/\nexport const model = (modelName, object) => {\n  if (hasValue(object)) {\n    model[modelName] = object;\n  }\n  return get(modelName, model);\n};\nacid.superMethod(model);\nassign(acid, {\n  model\n});\n","import acid from '../namespace/index';\nimport { assign } from '../internal/object';\nimport { isEqual } from './isEqual';\n/**\n  * Performs a toggle between 2 values using a deep or strict comparison.\n  *\n  * @function toggle\n  * @type {Function}\n  * @param  {(string|number|Object|Array)} value - Strictly compared against the on argument.\n  * @param {(string|number|Object|Array)} on -  Strictly compared against the value argument.\n  * @param {(string|number|Object|Array)} off -  Value to be returned.\n  * @returns {(string|number|Object|Array)} - The opposing value to the current.\n  *\n  * @example\n  * toggle(1, 2, 3);\n  * //=> 2\n*/\nexport const toggle = (value, on, off) => {\n  return (isEqual(on, value)) ? off : on;\n};\nassign(acid, {\n  toggle\n});\n"],"names":["superMethod","objectNative","Object","keys","is","assign","getOwnPropertyDescriptor","defineProperty","getOwnPropertyNames","length","objectSize","asyncEach","push","compactMapArray","eachArray","eachArrayRight","eachWhile","filterArray","mapArray","mapArrayRight","mapWhile","times","timesMap","toString","constructor","Array","isArray","String","Number","trim","slice","Function","test","acid","getFileExtension","match","has","includes","hasLength","hasValue","isDecimal","isEmpty","isFileCSS","isFileJS","isFileJSON","isFunction","isNull","isNumber","isPlainObject","isString","isUndefined","ensureArray","reduce","concat","flatten","flattenDeep","remove","splice","indexOf","chunk","forEach","flow","flowRight","rest","clear","arraySortToObject","groupBy","right","cloneArray","Math","floor","random","add","deduct","divide","increment","minus","multiply","randomArbitrary","randomInt","remainder","sample","compact","filter","indexBy","from","toArray","shuffle","countBy","countKey","countNoKey","initial","min","smallest","range","rangeRight","intersect","sortAlpha","sort","difference","invoke","drop","dropRight","isMatchArray","sortedIndex","max","largest","sumOf","eachAsync","last","take","takeRight","mapAsync","unique","union","compactMapAsync","numSort","findDifference","start","end","startIndex","endIndex","arrayToObject","without","findItem","find","findIndex","partition","xor","findSum","pluck","zip","map","unZip","first","rNumSort","navigator","userAgent","toLowerCase","replace","split","isAgent","addEventListener","eventAdd","eventRemove","removeEventListener","isEnter","keyCode","appState","document","createDocumentFragment","bind","createFragment","appendChild","compactMapObject","eachObject","filterObject","mapObject","whileObject","setAttribute","getAttribute","nodeAttribute","Promise","promise","substr","chunkString","RegExp","initialString","insertInRange","restString","rightString","getElementsByClassName","getElementsByTagName","getElementById","querySelector","querySelectorAll","getByClass","getById","getByTag","selector","createElement","async","src","importcss","href","rel","type","importjs","readyState","isDocumentReady","bodyHeight","body","offsetHeight","bodyWidth","offsetWidth","windowHeight","window","innerHeight","windowWidth","innerWidth","requestAnimationFrame","saveDimensions","updateDimensions","ifInvoke","batch","location","protocol","hostname","hardware","cores","hardwareConcurrency","host","name","protocolSocket","info","JSON","jsonParse","stringify","alert","important","notify","warning","addConsoleTheme","cnsl","console","trace","getNewest","sortNewest","getOldest","sortOldest","ary","curry","result","curryRight","unshift","onAfter","onBefore","once","stubObject","stubArray","stubString","stubTrue","stubFalse","noop","compactMap","each","bindAll","negate","over","overEvery","setTimeout","debounce","clearTimeout","interval","setInterval","throttle","timer","methods","value","chain","link","done","inAsync","inSync","nthArg","reArg","wrap","list","wrapBefore","reverse","isNumberEqual","isNumberInRange","isZero","hasAnyKeys","include","hasKeys","pick","compactKeys","isMatchObject","unZipObject","zipObject","invert","omit","camelCase","toUpperCase","kebabCase","snakeCase","upperCase","replaceList","join","decodeURIComponent","htmlEntities","rawURLDecode","sanitize","tokenize","words","truncate","truncateRight","spaceFirstLetter","upperFirst","upperFirstAll","upperFirstOnly","upperFirstOnlyAll","assignDeep","prototype","cacheNativeMethod","call","ifNotEqual","isEqual","propertyMatch","toPath","shift","free","uid","get","model","toggle"],"mappings":"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"}